<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chicken vs Cow Battle</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Space Grotesk', 'Segoe UI', sans-serif;
      background: radial-gradient(circle at 20% 20%, #0c1119 0%, #060910 55%, #02040a 100%);
      color: #f5f7ff;
    }
    canvas { display: block; width: 100vw; height: 100vh; outline: none; }
    .hud {
      position: fixed;
      inset: 18px auto auto 18px;
      max-width: 340px;
      padding: 16px 18px 14px;
      background: rgba(10,16,28,0.65);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 40px rgba(0,0,0,0.55);
    }
    h1 { margin: 0 0 6px; font-size: 1.4rem; letter-spacing: 0.02em; }
    p { margin: 4px 0; color: rgba(245,247,255,0.78); font-size: 0.95rem; line-height: 1.35; }
    .statline { display: flex; gap: 12px; margin-top: 10px; font-weight: 600; }
    .chip { padding: 6px 10px; border-radius: 10px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.08); }
    .legend { margin-top: 10px; font-size: 0.86rem; color: rgba(245,247,255,0.72); }
    @media (max-width: 640px) {
      .hud { inset: auto 12px 12px auto; max-width: calc(100vw - 24px); }
      h1 { font-size: 1.2rem; }
    }
  </style>
</head>
<body>
  <canvas id="battle"></canvas>
  <section class="hud">
    <h1>Chicken vs Cow Battle</h1>
    <p>100 speedy chickens rush 3 chunky cows. Drag to orbit, scroll to zoom. Watch the barnyard mayhem!</p>
    <div class="statline">
      <span class="chip">Chickens: <span id="chickenCount">0</span></span>
      <span class="chip">Cows: <span id="cowCount">0</span></span>
    </div>
    <p class="legend">Chickens swarm and peck nearby cows. Cows stomp in an area and body-check on contact.</p>
  </section>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    const canvas = document.getElementById('battle');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0f18);
    scene.fog = new THREE.Fog(0x0a0f18, 120, 220);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 600);
    camera.position.set(-60, 42, 90);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 30;
    controls.maxDistance = 180;

    // Lights
    scene.add(new THREE.AmbientLight(0x6f92c9, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(40, 80, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(1024, 1024);
    dirLight.shadow.camera.near = 10;
    dirLight.shadow.camera.far = 200;
    dirLight.shadow.camera.left = -80;
    dirLight.shadow.camera.right = 80;
    dirLight.shadow.camera.top = 80;
    dirLight.shadow.camera.bottom = -80;
    scene.add(dirLight);
    scene.add(new THREE.HemisphereLight(0x5ab6ff, 0x0f0f14, 0.35));

    // Ground
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x1a2435,
      roughness: 0.9,
      metalness: 0.05,
      emissive: 0x0a101c,
      emissiveIntensity: 0.2
    });
    const ground = new THREE.Mesh(new THREE.CircleGeometry(160, 80), groundMat);
    ground.receiveShadow = true;
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // HUD elements
    const chickenCountEl = document.getElementById('chickenCount');
    const cowCountEl = document.getElementById('cowCount');

    // Helpers
    const worldRadius = 150;
    const tmpVec = new THREE.Vector3();

    function clampToField(vec) {
      const len = vec.length();
      if (len > worldRadius) {
        vec.multiplyScalar(worldRadius / len);
      }
    }

    function createChickenMesh() {
      const g = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.SphereGeometry(1.2, 14, 12),
        new THREE.MeshStandardMaterial({ color: 0xfff4d6, roughness: 0.5, metalness: 0.05 })
      );
      body.castShadow = true;
      g.add(body);

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 12, 10),
        new THREE.MeshStandardMaterial({ color: 0xfff1c0, roughness: 0.5 })
      );
      head.position.set(0, 1.1, 0.7);
      head.castShadow = true;
      g.add(head);

      const beak = new THREE.Mesh(
        new THREE.ConeGeometry(0.25, 0.6, 8),
        new THREE.MeshStandardMaterial({ color: 0xffa53b })
      );
      beak.position.set(0, 0.95, 1.25);
      beak.rotation.x = Math.PI / 2;
      beak.castShadow = true;
      g.add(beak);

      const comb = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.15, 0.45, 6, 10),
        new THREE.MeshStandardMaterial({ color: 0xe5423a, emissive: 0x3c0c0c, emissiveIntensity: 0.6 })
      );
      comb.position.set(0, 1.55, 0.6);
      comb.castShadow = true;
      g.add(comb);

      const legMat = new THREE.MeshStandardMaterial({ color: 0xd48c3d, roughness: 0.6 });
      const legGeo = new THREE.CylinderGeometry(0.12, 0.16, 0.9, 6);
      const footGeo = new THREE.BoxGeometry(0.35, 0.12, 0.5);
      for (let i = 0; i < 2; i++) {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.castShadow = true;
        leg.position.set(i === 0 ? -0.35 : 0.35, -0.6, 0.2);
        g.add(leg);
        const foot = new THREE.Mesh(footGeo, legMat);
        foot.castShadow = true;
        foot.position.set(leg.position.x, -1.0, 0.4);
        g.add(foot);
      }

      return g;
    }

    function createCowMesh() {
      const g = new THREE.Group();
      const coat = new THREE.MeshStandardMaterial({ color: 0xdedede, roughness: 0.6, metalness: 0.05 });
      const body = new THREE.Mesh(new THREE.BoxGeometry(4.6, 2.4, 2.8, 1, 1, 1), coat);
      body.castShadow = true;
      g.add(body);

      const head = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.4, 1.8), coat);
      head.castShadow = true;
      head.position.set(0, 0.4, 2.1);
      g.add(head);

      const snout = new THREE.Mesh(
        new THREE.BoxGeometry(1.3, 0.8, 1.1),
        new THREE.MeshStandardMaterial({ color: 0xc4826e, roughness: 0.4 })
      );
      snout.position.set(0, -0.1, 3.0);
      snout.castShadow = true;
      g.add(snout);

      const hornMat = new THREE.MeshStandardMaterial({ color: 0xf7e7c6, roughness: 0.3 });
      const hornGeo = new THREE.ConeGeometry(0.25, 0.8, 8);
      const hornL = new THREE.Mesh(hornGeo, hornMat);
      hornL.position.set(-0.5, 1.0, 2.1);
      hornL.rotation.x = -Math.PI / 2.6;
      hornL.castShadow = true;
      g.add(hornL);
      const hornR = hornL.clone();
      hornR.position.x *= -1;
      g.add(hornR);

      const legMat = new THREE.MeshStandardMaterial({ color: 0x554437, roughness: 0.7 });
      const legGeo = new THREE.CylinderGeometry(0.28, 0.32, 2.0, 8);
      const positions = [
        [-1.6, -1.2, -1.0], [1.6, -1.2, -1.0],
        [-1.6, -1.2, 1.0], [1.6, -1.2, 1.0]
      ];
      for (const p of positions) {
        const leg = new THREE.Mesh(legGeo, legMat);
        leg.castShadow = true;
        leg.position.set(p[0], p[1], p[2]);
        g.add(leg);
      }

      // Simple spots
      const spotMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.8 });
      const spotGeo = new THREE.BoxGeometry(1.1, 0.6, 0.5);
      const spot1 = new THREE.Mesh(spotGeo, spotMat);
      spot1.position.set(-1.0, 0.2, 0.4);
      spot1.castShadow = true;
      g.add(spot1);
      const spot2 = spot1.clone();
      spot2.position.set(1.2, -0.1, -0.4);
      g.add(spot2);

      return g;
    }

    // Entities
    const chickens = [];
    const cows = [];
    const chickenCount = 100;
    const cowCount = 3;

    function addHitFlash(position, color = 0xffd447) {
      const particles = new THREE.Group();
      const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
      for (let i = 0; i < 8; i++) {
        const spark = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 6), mat.clone());
        const angle = (i / 8) * Math.PI * 2;
        spark.position.set(Math.cos(angle) * 0.6, 0.4 + Math.random() * 0.3, Math.sin(angle) * 0.6);
        particles.add(spark);
      }
      particles.position.copy(position);
      scene.add(particles);
      let life = 0.4;
      const update = (dt) => {
        life -= dt;
        particles.children.forEach((c) => {
          c.material.opacity = Math.max(life * 2, 0);
          c.position.multiplyScalar(1.06);
        });
        particles.scale.multiplyScalar(1.03);
        if (life <= 0) {
          scene.remove(particles);
          particles.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
          return false;
        }
        return true;
      };
      flashUpdaters.push(update);
    }

    const flashUpdaters = [];

    function spawnArmies() {
      for (let i = 0; i < chickenCount; i++) {
        const mesh = createChickenMesh();
        mesh.scale.setScalar(0.9 + Math.random() * 0.15);
        mesh.position.set(
          (Math.random() - 0.5) * 80,
          0,
          (Math.random() - 0.5) * 80
        );
        mesh.castShadow = true;
        scene.add(mesh);
        chickens.push({
          mesh,
          pos: mesh.position.clone(),
          vel: new THREE.Vector3(),
          health: 10,
          cooldown: Math.random() * 0.6,
          alive: true,
          fade: 1
        });
      }

      const cowSpawns = [new THREE.Vector3(-40, 0, 50), new THREE.Vector3(50, 0, -30), new THREE.Vector3(-60, 0, -50)];
      for (let i = 0; i < cowCount; i++) {
        const mesh = createCowMesh();
        mesh.scale.setScalar(11);
        mesh.position.copy(cowSpawns[i % cowSpawns.length]);
        mesh.castShadow = true;
        scene.add(mesh);
        cows.push({
          mesh,
          pos: mesh.position.clone(),
          vel: new THREE.Vector3(),
          health: 2200,
          stompCd: Math.random() * 1.2,
          alive: true,
          fade: 1
        });
      }
      updateHud();
    }

    function updateHud() {
      chickenCountEl.textContent = chickens.filter((c) => c.alive).length;
      cowCountEl.textContent = cows.filter((c) => c.alive).length;
    }

    function steerTowards(entityPos, targetPos, strength) {
      tmpVec.copy(targetPos).sub(entityPos);
      const dist = tmpVec.length() + 1e-5;
      return tmpVec.multiplyScalar(strength / dist);
    }

    function updateChickens(dt) {
      const livingCows = cows.filter((c) => c.alive);
      if (!livingCows.length) return;

      for (const chicken of chickens) {
        if (!chicken.alive) continue;
        chicken.cooldown = Math.max(0, chicken.cooldown - dt);

        // Target nearest cow
        let nearest = null;
        let nearestDistSq = Infinity;
        for (const cow of livingCows) {
          tmpVec.subVectors(cow.pos, chicken.pos);
          const d2 = tmpVec.lengthSq();
          if (d2 < nearestDistSq) {
            nearestDistSq = d2;
            nearest = cow;
          }
        }

        const accel = new THREE.Vector3();
        if (nearest) {
          accel.add(steerTowards(chicken.pos, nearest.pos, 18));
          // Attack if close
          const dist = Math.sqrt(nearestDistSq);
          if (dist < 2.6 && chicken.cooldown <= 0) {
            nearest.health -= 1.6;
            chicken.cooldown = 0.75;
            addHitFlash(nearest.pos, 0xffc257);
          }
        }

        // Separation from other chickens (simple, skip every other)
        for (let i = 0; i < chickens.length; i += 2) {
          const other = chickens[i];
          if (other === chicken || !other.alive) continue;
          const diff = tmpVec.subVectors(chicken.pos, other.pos);
          const d2 = diff.lengthSq();
          if (d2 < 9 && d2 > 0.001) {
            accel.add(diff.normalize().multiplyScalar(25 / d2));
          }
        }

        // Gentle jitter to avoid perfect lines
        accel.x += (Math.random() - 0.5) * 6;
        accel.z += (Math.random() - 0.5) * 6;

        chicken.vel.addScaledVector(accel, dt);
        chicken.vel.multiplyScalar(0.9);
        chicken.vel.clampLength(0, 12);
        chicken.pos.addScaledVector(chicken.vel, dt);
        clampToField(chicken.pos);
        chicken.mesh.position.copy(chicken.pos);
        chicken.mesh.rotation.y = Math.atan2(chicken.vel.x, chicken.vel.z) + Math.PI;
      }
    }

    function updateCows(dt) {
      const livingChickens = chickens.filter((c) => c.alive);
      if (!livingChickens.length) return;

      for (const cow of cows) {
        if (!cow.alive) continue;
        cow.stompCd = Math.max(0, cow.stompCd - dt);

        // Find nearest chicken
        let nearest = null;
        let nearestDistSq = Infinity;
        for (const chick of livingChickens) {
          tmpVec.subVectors(chick.pos, cow.pos);
          const d2 = tmpVec.lengthSq();
          if (d2 < nearestDistSq) {
            nearestDistSq = d2;
            nearest = chick;
          }
        }

        const accel = new THREE.Vector3();
        if (nearest) {
          accel.add(steerTowards(cow.pos, nearest.pos, 12));
          const dist = Math.sqrt(nearestDistSq);

          // Body check
          if (dist < 2.6 && cow.stompCd < 0.2) {
            nearest.health -= 80;
            addHitFlash(nearest.pos, 0xff6f6f);
            tmpVec.subVectors(nearest.pos, cow.pos).setY(0).normalize();
            nearest.vel.addScaledVector(tmpVec, 22);
            cow.stompCd = 0.7;
          }

          // Stomp area attack
          if (cow.stompCd <= 0) {
            for (const chick of livingChickens) {
              tmpVec.subVectors(chick.pos, cow.pos);
              const d = tmpVec.length();
              if (d < 5.2) {
                chick.health -= 26;
                chick.vel.addScaledVector(tmpVec.normalize(), 18 * (1 - d / 5.2));
                addHitFlash(chick.pos, 0xff8b5f);
              }
            }
            cow.stompCd = 1.8;
          }
        }

        // Mild cohesion so cows cluster a bit
        for (const other of cows) {
          if (other === cow || !other.alive) continue;
          const sep = tmpVec.subVectors(cow.pos, other.pos);
          const d2 = sep.lengthSq();
          if (d2 < 36 && d2 > 0.001) {
            accel.add(sep.normalize().multiplyScalar(8 / d2));
          }
        }

        cow.vel.addScaledVector(accel, dt);
        cow.vel.multiplyScalar(0.9);
        cow.vel.clampLength(0, 9);
        cow.pos.addScaledVector(cow.vel, dt);
        clampToField(cow.pos);
        cow.mesh.position.copy(cow.pos);
        cow.mesh.rotation.y = Math.atan2(cow.vel.x, cow.vel.z) + Math.PI;
      }
    }

    function handleHealthAndRemoval(dt) {
      let hudDirty = false;
      for (const chicken of chickens) {
        if (!chicken.alive) continue;
        if (chicken.health <= 0) {
          chicken.alive = false;
          hudDirty = true;
        }
        if (!chicken.alive) {
          chicken.fade -= dt * 1.2;
          chicken.mesh.scale.multiplyScalar(0.95);
          chicken.mesh.position.y -= dt * 2;
          if (chicken.fade <= 0.1) {
            scene.remove(chicken.mesh);
          }
        }
      }

      for (const cow of cows) {
        if (!cow.alive) continue;
        if (cow.health <= 0) {
          cow.alive = false;
          hudDirty = true;
        }
        if (!cow.alive) {
          cow.fade -= dt * 0.5;
          cow.mesh.scale.multiplyScalar(0.97);
          cow.mesh.position.y -= dt * 1.5;
          cow.mesh.traverse((child) => {
            if (child.material && child.material.emissive) {
              child.material.emissiveIntensity = Math.max(0, child.material.emissiveIntensity - dt * 2);
            }
          });
          if (cow.fade <= 0.1) {
            scene.remove(cow.mesh);
          }
        }
      }

      if (hudDirty) updateHud();
    }

    function updateFlashes(dt) {
      for (let i = flashUpdaters.length - 1; i >= 0; i--) {
        const alive = flashUpdaters[i](dt);
        if (!alive) flashUpdaters.splice(i, 1);
      }
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(clock.getDelta(), 0.05);
      const dt = delta * 12; // slowed time scale for clearer combat

      updateChickens(dt);
      updateCows(dt);
      handleHealthAndRemoval(dt);
      updateFlashes(dt);

      controls.update();
      renderer.render(scene, camera);
    }

    spawnArmies();
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
