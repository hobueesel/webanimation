<!DOCTYPE html>
<!-- saved from url=(0063)file:///C:/Users/krist/Documents/Code/webanimation/index36.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowy Starry Night</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="1536" height="729"></canvas>

    <!-- Vertex Shader for Snow -->
    <script id="snow-vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute float aSize;
        attribute float aSpeed;
        attribute float aOffset;
        
        uniform float uTime;
        uniform vec2 uResolution;
        uniform float uScale;
        uniform float uDepth;
        uniform float uSpeedMultiplier;
        
        varying float vAlpha;
        
        void main() {
            vec3 pos = aPosition;
            
            // Animate snow falling
            float fallProgress = mod(uTime * aSpeed * uSpeedMultiplier + aOffset, 2.0);
            pos.y = 1.0 - fallProgress;
            
            // Add some horizontal drift
            pos.x += sin(uTime * 0.5 + aOffset * 10.0) * 0.05;
            
            // Fade in/out at top and bottom
            vAlpha = smoothstep(0.0, 0.1, fallProgress) * smoothstep(2.0, 1.8, fallProgress) * uDepth;
            
            gl_Position = vec4(pos.x * 2.0 - 1.0, pos.y * 2.0 - 1.0, pos.z, 1.0);
            gl_PointSize = aSize * (uResolution.y / 800.0) * uScale;
        }
    </script>

    <!-- Fragment Shader for Snow -->
    <script id="snow-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if(dist > 0.5) {
                discard;
            }
            
            float alpha = (1.0 - dist * 2.0) * vAlpha;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
    </script>

    <!-- Vertex Shader for Accumulated Snow -->
    <script id="accumulated-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        attribute float aSize;
        
        uniform vec2 uResolution;
        uniform float uScale;
        
        void main() {
            gl_Position = vec4(aPosition.x * 2.0 - 1.0, aPosition.y * 2.0 - 1.0, 0.0, 1.0);
            gl_PointSize = aSize * (uResolution.y / 800.0) * uScale;
        }
    </script>

    <!-- Fragment Shader for Accumulated Snow -->
    <script id="accumulated-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if(dist > 0.5) {
                discard;
            }
            
            float alpha = 1.0 - dist * 2.0;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
    </script>

    <!-- Vertex Shader for Background -->
    <script id="bg-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        varying vec2 vUv;
        
        void main() {
            vUv = aPosition * 0.5 + 0.5;
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader for Background -->
    <script id="bg-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform float uTime;
        uniform vec2 uResolution;
        
        varying vec2 vUv;
        
        // Simple noise function
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        
        void main() {
            vec2 uv = vUv;
            
            // Sky gradient - sunset to night
            vec3 horizonColor = vec3(1.0, 0.4, 0.2); // Sunset orange
            vec3 skyColor = vec3(0.1, 0.05, 0.2); // Deep purple night
            vec3 zenithColor = vec3(0.0, 0.0, 0.05); // Almost black
            
            // Create gradient from bottom to top
            float horizonMix = smoothstep(0.4, 0.6, uv.y);
            float zenithMix = smoothstep(0.6, 0.9, uv.y);
            
            vec3 skyGradient = mix(horizonColor, skyColor, horizonMix);
            skyGradient = mix(skyGradient, zenithColor, zenithMix);
            
            // Ground/Earth
            if(uv.y < 0.4) {
                float groundMix = smoothstep(0.4, 0.3, uv.y);
                vec3 groundColor = vec3(0.05, 0.03, 0.08); // Dark ground
                vec3 groundHighlight = vec3(0.3, 0.15, 0.1); // Warm glow from sunset
                
                // Add sunset glow to ground
                float glowAmount = smoothstep(0.4, 0.35, uv.y) * (1.0 - smoothstep(0.2, 0.0, uv.y));
                vec3 ground = mix(groundColor, groundHighlight, glowAmount * 0.3);
                
                skyGradient = mix(skyGradient, ground, groundMix);
            }
            
            gl_FragColor = vec4(skyGradient, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Get shader source from script tag
        function getShaderSource(id) {
            return document.getElementById(id).textContent;
        }

        // Create background program
        const bgVertexShader = compileShader(gl, getShaderSource('bg-vertex-shader'), gl.VERTEX_SHADER);
        const bgFragmentShader = compileShader(gl, getShaderSource('bg-fragment-shader'), gl.FRAGMENT_SHADER);
        const bgProgram = createProgram(gl, bgVertexShader, bgFragmentShader);

        // Background quad
        const bgVertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const bgBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);

        const bgPositionLocation = gl.getAttribLocation(bgProgram, 'aPosition');
        const bgTimeLocation = gl.getUniformLocation(bgProgram, 'uTime');
        const bgResolutionLocation = gl.getUniformLocation(bgProgram, 'uResolution');

        // Create snow program
        const snowVertexShader = compileShader(gl, getShaderSource('snow-vertex-shader'), gl.VERTEX_SHADER);
        const snowFragmentShader = compileShader(gl, getShaderSource('snow-fragment-shader'), gl.FRAGMENT_SHADER);
        const snowProgram = createProgram(gl, snowVertexShader, snowFragmentShader);

        // Snow particles - different amounts per layer
        const layer1Count = 1000;
        const layer2Count = 10000;
        const layer3Count = 30000;
        const numSnowflakes = layer1Count + layer2Count + layer3Count;
        const snowPositions = [];
        const snowSizes = [];
        const snowSpeeds = [];
        const snowOffsets = [];

        for (let i = 0; i < numSnowflakes; i++) {
            // Position
            snowPositions.push(Math.random()); // x
            snowPositions.push(Math.random()); // y
            snowPositions.push(Math.random() * 0.5); // z (for depth)
            
            // Size (larger in front)
            const depth = snowPositions[i * 3 + 2];
            snowSizes.push(2.0 + (1.0 - depth) * 4.0);
            
            // Speed (faster in front)
            snowSpeeds.push(0.1 + (1.0 - depth) * 0.3);
            
            // Random offset for staggered animation
            snowOffsets.push(Math.random() * 2.0);
        }

        // Create buffers for snow
        const snowPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowPositions), gl.STATIC_DRAW);

        const snowSizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowSizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowSizes), gl.STATIC_DRAW);

        const snowSpeedBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowSpeedBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowSpeeds), gl.STATIC_DRAW);

        const snowOffsetBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowOffsetBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowOffsets), gl.STATIC_DRAW);

        // Get attribute locations for snow
        const snowPositionLocation = gl.getAttribLocation(snowProgram, 'aPosition');
        const snowSizeLocation = gl.getAttribLocation(snowProgram, 'aSize');
        const snowSpeedLocation = gl.getAttribLocation(snowProgram, 'aSpeed');
        const snowOffsetLocation = gl.getAttribLocation(snowProgram, 'aOffset');
        const snowTimeLocation = gl.getUniformLocation(snowProgram, 'uTime');
        const snowResolutionLocation = gl.getUniformLocation(snowProgram, 'uResolution');
        const snowScaleLocation = gl.getUniformLocation(snowProgram, 'uScale');
        const snowDepthLocation = gl.getUniformLocation(snowProgram, 'uDepth');
        const snowSpeedMultiplierLocation = gl.getUniformLocation(snowProgram, 'uSpeedMultiplier');

        // Create accumulated snow program
        const accVertexShader = compileShader(gl, getShaderSource('accumulated-vertex-shader'), gl.VERTEX_SHADER);
        const accFragmentShader = compileShader(gl, getShaderSource('accumulated-fragment-shader'), gl.FRAGMENT_SHADER);
        const accProgram = createProgram(gl, accVertexShader, accFragmentShader);

        const accPositionLocation = gl.getAttribLocation(accProgram, 'aPosition');
        const accSizeLocation = gl.getAttribLocation(accProgram, 'aSize');
        const accResolutionLocation = gl.getUniformLocation(accProgram, 'uResolution');
        const accScaleLocation = gl.getUniformLocation(accProgram, 'uScale');

        // Snow accumulation system
        const ACCUMULATION_ZONE = 0.33; // Lower 1/3 of screen
        const HEIGHTMAP_RESOLUTION = 200; // Number of X buckets for height tracking
        
        // Each layer has its own heightmap and accumulated particles
        const layers = [
            { 
                name: 'layer3',
                startIdx: 0,
                count: layer3Count,
                speedMult: 0.3,
                scale: 0.4,
                growthRate: 0.3, // Slower growth for far layer
                heightmap: new Float32Array(HEIGHTMAP_RESOLUTION).fill(0),
                accumulated: { positions: [], sizes: [], count: 0, buffer: null, sizeBuffer: null }
            },
            { 
                name: 'layer2',
                startIdx: layer3Count,
                count: layer2Count,
                speedMult: 0.6,
                scale: 0.7,
                growthRate: 0.6, // Medium growth
                heightmap: new Float32Array(HEIGHTMAP_RESOLUTION).fill(0),
                accumulated: { positions: [], sizes: [], count: 0, buffer: null, sizeBuffer: null }
            },
            { 
                name: 'layer1',
                startIdx: layer3Count + layer2Count,
                count: layer1Count,
                speedMult: 1.0,
                scale: 1.0,
                growthRate: 1.0, // Faster growth for near layer
                heightmap: new Float32Array(HEIGHTMAP_RESOLUTION).fill(0),
                accumulated: { positions: [], sizes: [], count: 0, buffer: null, sizeBuffer: null }
            }
        ];

        // Track which particles have already accumulated
        const accumulatedParticles = new Set();

        // Animation loop
        let startTime = Date.now();

        function getHeightmapIndex(x) {
            return Math.floor(x * HEIGHTMAP_RESOLUTION);
        }

        function getHeightAtPosition(layer, x) {
            const idx = getHeightmapIndex(x);
            if (idx < 0 || idx >= HEIGHTMAP_RESOLUTION) return 0;
            return layer.heightmap[idx];
        }

        function addSnowToHeightmap(layer, x, amount) {
            const idx = getHeightmapIndex(x);
            if (idx >= 0 && idx < HEIGHTMAP_RESOLUTION) {
                layer.heightmap[idx] += amount * layer.growthRate;
            }
        }

        function checkAndAccumulateSnow(currentTime) {
            layers.forEach(layer => {
                // Check a subset of particles each frame for performance
                const particlesToCheck = Math.min(500, layer.count);
                
                for (let i = 0; i < particlesToCheck; i++) {
                    const randomIdx = layer.startIdx + Math.floor(Math.random() * layer.count);
                    const particleKey = `${layer.name}_${randomIdx}`;
                    
                    // Skip if already accumulated
                    if (accumulatedParticles.has(particleKey)) continue;
                    
                    // Get particle position
                    const x = snowPositions[randomIdx * 3];
                    const speed = snowSpeeds[randomIdx];
                    const offset = snowOffsets[randomIdx];
                    const size = snowSizes[randomIdx];
                    
                    // Calculate current Y position
                    const fallProgress = (currentTime * speed * layer.speedMult + offset) % 2.0;
                    const y = 1.0 - fallProgress;
                    
                    // Calculate X position with drift
                    const drift = Math.sin(currentTime * 0.5 + offset * 10.0) * 0.05;
                    const actualX = x + drift;
                    
                    // Check if in accumulation zone
                    if (y <= ACCUMULATION_ZONE) {
                        // Get current height at this X position
                        const currentHeight = getHeightAtPosition(layer, actualX);
                        const groundY = 0; // Ground is at bottom (y=0)
                        const landingY = groundY + currentHeight; // Snow grows upwards
                        
                        // If particle reached the landing height
                        if (y <= landingY + 0.01) { // Small buffer for detection
                            // Add multiple particles around the landing position for better coverage
                            const spreadCount = 3; // Add 3 particles per landing
                            for (let s = 0; s < spreadCount; s++) {
                                const spreadX = actualX + (Math.random() - 0.5) * 0.01; // Small horizontal spread
                                const spreadY = landingY + (Math.random() - 0.5) * 0.005; // Small vertical spread
                                layer.accumulated.positions.push(spreadX, spreadY);
                                layer.accumulated.sizes.push(size * 2.5); // Increase size significantly for full coverage
                                layer.accumulated.count++;
                            }
                            
                            // Update heightmap
                            const particleHeightContribution = size * 0.0015; // Increment per particle
                            addSnowToHeightmap(layer, actualX, particleHeightContribution);
                            
                            // Mark as accumulated
                            accumulatedParticles.add(particleKey);
                            
                            // Update buffers every 10 particles for performance
                            if (layer.accumulated.count % 10 === 0) {
                                if (!layer.accumulated.buffer) {
                                    layer.accumulated.buffer = gl.createBuffer();
                                    layer.accumulated.sizeBuffer = gl.createBuffer();
                                }
                                
                                gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.buffer);
                                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(layer.accumulated.positions), gl.STATIC_DRAW);
                                
                                gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.sizeBuffer);
                                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(layer.accumulated.sizes), gl.STATIC_DRAW);
                            }
                        }
                    }
                }
            });
        }

        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Render background
            gl.useProgram(bgProgram);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
            gl.enableVertexAttribArray(bgPositionLocation);
            gl.vertexAttribPointer(bgPositionLocation, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(bgTimeLocation, currentTime);
            gl.uniform2f(bgResolutionLocation, canvas.width, canvas.height);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Render snow in three parallax layers
            gl.useProgram(snowProgram);
            
            // Enable blending for transparent snow
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            // Set up attributes (same for all layers)
            gl.bindBuffer(gl.ARRAY_BUFFER, snowPositionBuffer);
            gl.enableVertexAttribArray(snowPositionLocation);
            gl.vertexAttribPointer(snowPositionLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowSizeBuffer);
            gl.enableVertexAttribArray(snowSizeLocation);
            gl.vertexAttribPointer(snowSizeLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowSpeedBuffer);
            gl.enableVertexAttribArray(snowSpeedLocation);
            gl.vertexAttribPointer(snowSpeedLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowOffsetBuffer);
            gl.enableVertexAttribArray(snowOffsetLocation);
            gl.vertexAttribPointer(snowOffsetLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(snowTimeLocation, currentTime);
            gl.uniform2f(snowResolutionLocation, canvas.width, canvas.height);
            
            // Layer 3 (furthest back - smallest, slowest, most transparent, most particles)
            gl.uniform1f(snowScaleLocation, 0.4);
            gl.uniform1f(snowDepthLocation, 0.3);
            gl.uniform1f(snowSpeedMultiplierLocation, 0.3); // 30% speed
            gl.drawArrays(gl.POINTS, 0, layer3Count);
            
            // Layer 2 (middle - medium size and speed)
            gl.uniform1f(snowScaleLocation, 0.7);
            gl.uniform1f(snowDepthLocation, 0.6);
            gl.uniform1f(snowSpeedMultiplierLocation, 0.6); // 60% speed
            gl.drawArrays(gl.POINTS, layer3Count, layer2Count);
            
            // Layer 1 (front - original size and full opacity and speed)
            gl.uniform1f(snowScaleLocation, 1.0);
            gl.uniform1f(snowDepthLocation, 1.0);
            gl.uniform1f(snowSpeedMultiplierLocation, 1.0); // 100% speed
            gl.drawArrays(gl.POINTS, layer3Count + layer2Count, layer1Count);
            
            gl.disable(gl.BLEND);

            // Check and accumulate snow
            checkAndAccumulateSnow(currentTime);

            // Render accumulated snow
            gl.useProgram(accProgram);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            gl.uniform2f(accResolutionLocation, canvas.width, canvas.height);

            // Render each layer's accumulated snow
            layers.forEach(layer => {
                if (layer.accumulated.count > 0 && layer.accumulated.buffer) {
                    gl.uniform1f(accScaleLocation, layer.scale);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.buffer);
                    gl.enableVertexAttribArray(accPositionLocation);
                    gl.vertexAttribPointer(accPositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.sizeBuffer);
                    gl.enableVertexAttribArray(accSizeLocation);
                    gl.vertexAttribPointer(accSizeLocation, 1, gl.FLOAT, false, 0, 0);
                    
                    gl.drawArrays(gl.POINTS, 0, layer.accumulated.count);
                }
            });
            
            gl.disable(gl.BLEND);

            requestAnimationFrame(render);
        }

        render();
    </script>

</body></html>