<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snowy Starry Night</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <!-- Vertex Shader for Snow -->
    <script id="snow-vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute float aSize;
        attribute float aSpeed;
        attribute float aOffset;
        
        uniform float uTime;
        uniform vec2 uResolution;
        uniform float uScale;
        uniform float uDepth;
        uniform float uSpeedMultiplier;
        
        varying float vAlpha;
        
        void main() {
            vec3 pos = aPosition;
            
            // Animate snow falling
            float fallProgress = mod(uTime * aSpeed * uSpeedMultiplier + aOffset, 2.0);
            pos.y = 1.0 - fallProgress;
            
            // Add some horizontal drift
            pos.x += sin(uTime * 0.5 + aOffset * 10.0) * 0.05;
            
            // Fade in/out at top and bottom
            vAlpha = smoothstep(0.0, 0.1, fallProgress) * smoothstep(2.0, 1.8, fallProgress) * uDepth;
            
            gl_Position = vec4(pos.x * 2.0 - 1.0, pos.y * 2.0 - 1.0, pos.z, 1.0);
            gl_PointSize = aSize * (uResolution.y / 800.0) * uScale;
        }
    </script>

    <!-- Fragment Shader for Snow -->
    <script id="snow-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if(dist > 0.5) {
                discard;
            }
            
            float alpha = (1.0 - dist * 2.0) * vAlpha;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
    </script>

    <!-- Vertex Shader for Background -->
    <script id="bg-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        varying vec2 vUv;
        
        void main() {
            vUv = aPosition * 0.5 + 0.5;
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader for Background -->
    <script id="bg-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform float uTime;
        uniform vec2 uResolution;
        
        varying vec2 vUv;
        
        // Simple noise function
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        
        void main() {
            vec2 uv = vUv;
            
            // Sky gradient - sunset to night
            vec3 horizonColor = vec3(1.0, 0.4, 0.2); // Sunset orange
            vec3 skyColor = vec3(0.1, 0.05, 0.2); // Deep purple night
            vec3 zenithColor = vec3(0.0, 0.0, 0.05); // Almost black
            
            // Create gradient from bottom to top
            float horizonMix = smoothstep(0.4, 0.6, uv.y);
            float zenithMix = smoothstep(0.6, 0.9, uv.y);
            
            vec3 skyGradient = mix(horizonColor, skyColor, horizonMix);
            skyGradient = mix(skyGradient, zenithColor, zenithMix);
            
            // Ground/Earth
            if(uv.y < 0.4) {
                float groundMix = smoothstep(0.4, 0.3, uv.y);
                vec3 groundColor = vec3(0.05, 0.03, 0.08); // Dark ground
                vec3 groundHighlight = vec3(0.3, 0.15, 0.1); // Warm glow from sunset
                
                // Add sunset glow to ground
                float glowAmount = smoothstep(0.4, 0.35, uv.y) * (1.0 - smoothstep(0.2, 0.0, uv.y));
                vec3 ground = mix(groundColor, groundHighlight, glowAmount * 0.3);
                
                skyGradient = mix(skyGradient, ground, groundMix);
            }
            
            gl_FragColor = vec4(skyGradient, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Get shader source from script tag
        function getShaderSource(id) {
            return document.getElementById(id).textContent;
        }

        // Create background program
        const bgVertexShader = compileShader(gl, getShaderSource('bg-vertex-shader'), gl.VERTEX_SHADER);
        const bgFragmentShader = compileShader(gl, getShaderSource('bg-fragment-shader'), gl.FRAGMENT_SHADER);
        const bgProgram = createProgram(gl, bgVertexShader, bgFragmentShader);

        // Background quad
        const bgVertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const bgBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);

        const bgPositionLocation = gl.getAttribLocation(bgProgram, 'aPosition');
        const bgTimeLocation = gl.getUniformLocation(bgProgram, 'uTime');
        const bgResolutionLocation = gl.getUniformLocation(bgProgram, 'uResolution');

        // Create snow program
        const snowVertexShader = compileShader(gl, getShaderSource('snow-vertex-shader'), gl.VERTEX_SHADER);
        const snowFragmentShader = compileShader(gl, getShaderSource('snow-fragment-shader'), gl.FRAGMENT_SHADER);
        const snowProgram = createProgram(gl, snowVertexShader, snowFragmentShader);

        // Snow particles - different amounts per layer
        const layer1Count = 1000;
        const layer2Count = 10000;
        const layer3Count = 30000;
        const numSnowflakes = layer1Count + layer2Count + layer3Count;
        const snowPositions = [];
        const snowSizes = [];
        const snowSpeeds = [];
        const snowOffsets = [];

        for (let i = 0; i < numSnowflakes; i++) {
            // Position
            snowPositions.push(Math.random()); // x
            snowPositions.push(Math.random()); // y
            snowPositions.push(Math.random() * 0.5); // z (for depth)
            
            // Size (larger in front)
            const depth = snowPositions[i * 3 + 2];
            snowSizes.push(2.0 + (1.0 - depth) * 4.0);
            
            // Speed (faster in front)
            snowSpeeds.push(0.1 + (1.0 - depth) * 0.3);
            
            // Random offset for staggered animation
            snowOffsets.push(Math.random() * 2.0);
        }

        // Create buffers for snow
        const snowPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowPositions), gl.STATIC_DRAW);

        const snowSizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowSizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowSizes), gl.STATIC_DRAW);

        const snowSpeedBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowSpeedBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowSpeeds), gl.STATIC_DRAW);

        const snowOffsetBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowOffsetBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowOffsets), gl.STATIC_DRAW);

        // Get attribute locations for snow
        const snowPositionLocation = gl.getAttribLocation(snowProgram, 'aPosition');
        const snowSizeLocation = gl.getAttribLocation(snowProgram, 'aSize');
        const snowSpeedLocation = gl.getAttribLocation(snowProgram, 'aSpeed');
        const snowOffsetLocation = gl.getAttribLocation(snowProgram, 'aOffset');
        const snowTimeLocation = gl.getUniformLocation(snowProgram, 'uTime');
        const snowResolutionLocation = gl.getUniformLocation(snowProgram, 'uResolution');
        const snowScaleLocation = gl.getUniformLocation(snowProgram, 'uScale');
        const snowDepthLocation = gl.getUniformLocation(snowProgram, 'uDepth');
        const snowSpeedMultiplierLocation = gl.getUniformLocation(snowProgram, 'uSpeedMultiplier');

        // Animation loop
        let startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Render background
            gl.useProgram(bgProgram);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
            gl.enableVertexAttribArray(bgPositionLocation);
            gl.vertexAttribPointer(bgPositionLocation, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(bgTimeLocation, currentTime);
            gl.uniform2f(bgResolutionLocation, canvas.width, canvas.height);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Render snow in three parallax layers
            gl.useProgram(snowProgram);
            
            // Enable blending for transparent snow
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            // Set up attributes (same for all layers)
            gl.bindBuffer(gl.ARRAY_BUFFER, snowPositionBuffer);
            gl.enableVertexAttribArray(snowPositionLocation);
            gl.vertexAttribPointer(snowPositionLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowSizeBuffer);
            gl.enableVertexAttribArray(snowSizeLocation);
            gl.vertexAttribPointer(snowSizeLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowSpeedBuffer);
            gl.enableVertexAttribArray(snowSpeedLocation);
            gl.vertexAttribPointer(snowSpeedLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowOffsetBuffer);
            gl.enableVertexAttribArray(snowOffsetLocation);
            gl.vertexAttribPointer(snowOffsetLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(snowTimeLocation, currentTime);
            gl.uniform2f(snowResolutionLocation, canvas.width, canvas.height);
            
            // Layer 3 (furthest back - smallest, slowest, most transparent, most particles)
            gl.uniform1f(snowScaleLocation, 0.4);
            gl.uniform1f(snowDepthLocation, 0.3);
            gl.uniform1f(snowSpeedMultiplierLocation, 0.3); // 30% speed
            gl.drawArrays(gl.POINTS, 0, layer3Count);
            
            // Layer 2 (middle - medium size and speed)
            gl.uniform1f(snowScaleLocation, 0.7);
            gl.uniform1f(snowDepthLocation, 0.6);
            gl.uniform1f(snowSpeedMultiplierLocation, 0.6); // 60% speed
            gl.drawArrays(gl.POINTS, layer3Count, layer2Count);
            
            // Layer 1 (front - original size and full opacity and speed)
            gl.uniform1f(snowScaleLocation, 1.0);
            gl.uniform1f(snowDepthLocation, 1.0);
            gl.uniform1f(snowSpeedMultiplierLocation, 1.0); // 100% speed
            gl.drawArrays(gl.POINTS, layer3Count + layer2Count, layer1Count);
            
            gl.disable(gl.BLEND);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>