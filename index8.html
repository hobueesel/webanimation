<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Index8 - Solar System Canvas</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --glass:bg rgba(6,10,26,0.54);
      --border:rgba(255,255,255,0.1);
    }
    * { box-sizing:border-box; }
    body {
      margin:0;
      min-height:100vh;
      font-family:'Space Grotesk',"Trebuchet MS",sans-serif;
      background:radial-gradient(circle at 20% 20%,#15203a 0%,#05060d 55%,#020309 100%);
      color:#f7f9ff;
      overflow:hidden;
    }
    canvas {
      display:block;
      width:100vw;
      height:100vh;
      outline:none;
    }
    .overlay {
      position:fixed;
      inset:auto auto 28px 28px;
      max-width:320px;
      background:var(--glass);
      border:1px solid var(--border);
      border-radius:18px;
      padding:20px 22px 18px;
      backdrop-filter:blur(18px);
      box-shadow:0 25px 60px rgba(0,0,0,0.45);
    }
    h1 {
      margin:0 0 6px;
      font-size:1.65rem;
      letter-spacing:0.04em;
    }
    p {
      margin:0;
      font-size:0.95rem;
      line-height:1.35;
      color:rgba(247,249,255,0.75);
    }
    .legend {
      margin:16px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px;
      font-size:0.82rem;
    }
    .legend li {
      display:flex;
      align-items:center;
      gap:8px;
      color:rgba(247,249,255,0.75);
    }
    .chip {
      width:14px;
      height:14px;
      border-radius:7px;
      background:var(--tone,#fff);
      box-shadow:0 0 12px var(--tone,#fff);
      flex-shrink:0;
    }
    @media (max-width:640px) {
      .overlay {
        inset:auto 18px 18px auto;
        max-width:calc(100vw - 36px);
      }
      h1 { font-size:1.35rem; }
      .legend { grid-template-columns:repeat(3,minmax(0,1fr)); }
    }
  </style>
</head>
<body>
  <canvas id="universe"></canvas>
  <section class="overlay">
    <h1>Solar Drift</h1>
    <p>Drag to orbit, scroll to glide closer. Planet speeds are exaggerated so you can watch the dance in real time.</p>
    <ul class="legend">
      <li><span class="chip" style="--tone:#f8c56d"></span>Sun</li>
      <li><span class="chip" style="--tone:#c5b199"></span>Mercury</li>
      <li><span class="chip" style="--tone:#f5a971"></span>Venus</li>
      <li><span class="chip" style="--tone:#5eb7ff"></span>Earth</li>
      <li><span class="chip" style="--tone:#f16b5b"></span>Mars</li>
      <li><span class="chip" style="--tone:#efd08a"></span>Jupiter</li>
      <li><span class="chip" style="--tone:#d9b578"></span>Saturn</li>
      <li><span class="chip" style="--tone:#74f0d4"></span>Uranus</li>
      <li><span class="chip" style="--tone:#60a8ff"></span>Neptune</li>
    </ul>
  </section>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    const canvas = document.getElementById('universe');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.35;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x030409);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(-180, 120, 260);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 60;
    controls.maxDistance = 800;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.35;

    const G = 0.00045;
    const SUN_MASS = 420000;
    const TIME_ACCEL = 35;
    const MAX_COMETS = 4;
    const COMET_MIN_DELAY = 12;
    const COMET_MAX_DELAY = 24;
    const COMET_TRAIL_SEGMENTS = 140;
    const COMET_MAX_DISTANCE = 700;
    const PLANET_TRAIL_SEGMENTS = 220;

    const starGeometry = new THREE.BufferGeometry();
    const starVertices = [];
    for (let i = 0; i < 2000; i++) {
      starVertices.push(
        THREE.MathUtils.randFloatSpread(3000),
        THREE.MathUtils.randFloatSpread(3000),
        THREE.MathUtils.randFloatSpread(3000)
      );
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, sizeAttenuation: true, transparent: true, opacity: 0.8 });
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    const ambient = new THREE.AmbientLight(0x425a7a, 0.65);
    scene.add(ambient);

    const hemiLight = new THREE.HemisphereLight(0x6c8dff, 0x02040a, 0.55);
    scene.add(hemiLight);

    const rimLight = new THREE.DirectionalLight(0x88b4ff, 0.85);
    rimLight.position.set(120, 160, -80);
    scene.add(rimLight);

    const sunMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xfff1c0,
      emissive: 0xffc769,
      emissiveIntensity: 1.8,
      roughness: 0.35,
      metalness: 0,
      clearcoat: 1,
      clearcoatRoughness: 0.25
    });
    const sun = new THREE.Mesh(new THREE.SphereGeometry(20, 96, 96), sunMaterial);
    scene.add(sun);

    const sunLight = new THREE.PointLight(0xfff0c1, 4.5, 0, 2);
    sunLight.position.copy(sun.position);
    scene.add(sunLight);

    const planetConfigs = [
      { name: 'Mercury', radius: 32, size: 2.2, color: 0xc5b199, speed: 1.25, mass: 6 },
      { name: 'Venus', radius: 50, size: 4, color: 0xf5a971, speed: 1.1, mass: 12 },
      { name: 'Earth', radius: 70, size: 4.6, color: 0x5eb7ff, speed: 1.0, mass: 14, tilt: 6 },
      { name: 'Mars', radius: 90, size: 3.2, color: 0xf16b5b, speed: 0.85, mass: 7 },
      { name: 'Jupiter', radius: 130, size: 10, color: 0xefd08a, speed: 0.55, mass: 70 },
      { name: 'Saturn', radius: 170, size: 8.5, color: 0xd9b578, speed: 0.45, mass: 60, rings: { inner: 11, outer: 15 } },
      { name: 'Uranus', radius: 200, size: 6.3, color: 0x74f0d4, speed: 0.3, mass: 40 },
      { name: 'Neptune', radius: 230, size: 6.1, color: 0x60a8ff, speed: 0.28, mass: 45 }
    ];

    function createOrbit(radius) {
      const points = [];
      const segments = 256;
      for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(theta) * radius, 0, Math.sin(theta) * radius));
      }
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x26304d, transparent: true, opacity: 0.35 });
      const line = new THREE.LineLoop(geometry, material);
      scene.add(line);
    }

    function orbitalVelocity(radius, speedFactor = 1) {
      return Math.sqrt((G * SUN_MASS) / radius) * speedFactor;
    }

    const planetStates = planetConfigs.map(cfg => {
      const geometry = new THREE.SphereGeometry(cfg.size, 48, 48);
      const baseColor = new THREE.Color(cfg.color);
      const emissiveColor = baseColor.clone().multiplyScalar(0.55);
      const material = new THREE.MeshPhysicalMaterial({
        color: baseColor,
        roughness: 0.45,
        metalness: 0.08,
        emissive: emissiveColor,
        emissiveIntensity: 0.6
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData = cfg;

      if (cfg.rings) {
        const ringGeo = new THREE.RingGeometry(cfg.rings.inner, cfg.rings.outer, 128);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf6e1b1, side: THREE.DoubleSide, transparent: true, opacity: 0.55 });
        const rings = new THREE.Mesh(ringGeo, ringMat);
        rings.rotation.x = Math.PI / 2;
        mesh.add(rings);
      }

      createOrbit(cfg.radius);
      scene.add(mesh);

      const position = new THREE.Vector3(cfg.radius, 0, 0);
      const velocity = new THREE.Vector3(0, 0, orbitalVelocity(cfg.radius, cfg.speed));
      mesh.position.copy(position);

      const trailPositions = new Float32Array(PLANET_TRAIL_SEGMENTS * 3);
      for (let i = 0; i < PLANET_TRAIL_SEGMENTS; i++) {
        trailPositions[i * 3] = position.x;
        trailPositions[i * 3 + 1] = position.y;
        trailPositions[i * 3 + 2] = position.z;
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.LineBasicMaterial({
        color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.2).getHex(),
        transparent: true,
        opacity: 0.28
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      trail.frustumCulled = false;
      scene.add(trail);

      return {
        cfg,
        mesh,
        position,
        velocity,
        mass: cfg.mass,
        wobbleSeed: Math.random() * Math.PI * 2,
        trail,
        trailGeometry,
        trailPositions
      };
    });

    const moonGeo = new THREE.SphereGeometry(1.2, 24, 24);
    const moonMat = new THREE.MeshStandardMaterial({ color: 0xf6f3ef, roughness: 0.5 });
    const moon = new THREE.Mesh(moonGeo, moonMat);
    scene.add(moon);

    const comets = [];
    let cometSpawnTimer = 6;
    const impactFlares = [];
    let moonPhase = 0;
    let simTime = 0;

    function computeGravity(sourcePos, targetPos, mass) {
      const dir = new THREE.Vector3().copy(sourcePos).sub(targetPos);
      const distSq = Math.max(dir.lengthSq(), 25);
      return dir.multiplyScalar((G * mass) / Math.pow(distSq, 1.5));
    }

    function updatePlanetTrail(state) {
      const pos = state.trailPositions;
      for (let i = pos.length - 1; i >= 3; i -= 3) {
        pos[i] = pos[i - 3];
        pos[i - 1] = pos[i - 4];
        pos[i - 2] = pos[i - 5];
      }
      pos[0] = state.mesh.position.x;
      pos[1] = state.mesh.position.y;
      pos[2] = state.mesh.position.z;
      state.trailGeometry.attributes.position.needsUpdate = true;
    }

    function updatePlanets(dt) {
      for (const state of planetStates) {
        const accel = computeGravity(sun.position, state.position, SUN_MASS);
        state.velocity.addScaledVector(accel, dt);
        state.position.addScaledVector(state.velocity, dt);
        const wobble = state.cfg.tilt ? Math.sin(state.wobbleSeed + simTime * 0.12) * state.cfg.tilt : 0;
        state.mesh.position.set(state.position.x, wobble, state.position.z);
        state.mesh.rotation.y += 0.015 * dt * (state.cfg.size / 4);
        updatePlanetTrail(state);
      }
    }

    function updateMoon(dt) {
      const earth = planetStates.find(state => state.cfg.name === 'Earth');
      if (!earth) return;
      moonPhase += dt * 0.35;
      moon.position.set(
        earth.position.x + Math.cos(moonPhase) * 12,
        earth.mesh.position.y + Math.sin(moonPhase * 1.5) * 2,
        earth.position.z + Math.sin(moonPhase) * 12
      );
    }

    function spawnComet() {
      const startAngle = Math.random() * Math.PI * 2;
      const radius = THREE.MathUtils.randFloat(260, 360);
      const height = THREE.MathUtils.randFloat(-20, 20);
      const start = new THREE.Vector3(
        Math.cos(startAngle) * radius,
        height,
        Math.sin(startAngle) * radius
      );
      const toSun = new THREE.Vector3().copy(sun.position).sub(start).normalize();
      const tangent = new THREE.Vector3(-toSun.z, THREE.MathUtils.randFloat(-0.15, 0.15), toSun.x).normalize();
      const velocity = toSun.multiplyScalar(THREE.MathUtils.randFloat(1.2, 1.9))
        .add(tangent.multiplyScalar(THREE.MathUtils.randFloat(1.2, 2.4)));

      const cometMesh = new THREE.Mesh(
        new THREE.SphereGeometry(1.4, 24, 24),
        new THREE.MeshPhysicalMaterial({
          color: 0xd8f7ff,
          emissive: 0x9fdfff,
          emissiveIntensity: 2.2,
          roughness: 0.2,
          transmission: 0.65,
          thickness: 0.8
        })
      );
      cometMesh.position.copy(start);
      scene.add(cometMesh);

      const trailPositions = new Float32Array(COMET_TRAIL_SEGMENTS * 3);
      for (let i = 0; i < COMET_TRAIL_SEGMENTS; i++) {
        trailPositions[i * 3] = start.x;
        trailPositions[i * 3 + 1] = start.y;
        trailPositions[i * 3 + 2] = start.z;
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailLine = new THREE.Line(
        trailGeometry,
        new THREE.LineBasicMaterial({ color: 0x9ae5ff, transparent: true, opacity: 0.7 })
      );
      scene.add(trailLine);

      comets.push({
        mesh: cometMesh,
        position: start,
        velocity,
        trailGeometry,
        trailPositions,
        trailLine,
        alive: true
      });
    }

    function updateCometTrail(comet) {
      const pos = comet.trailPositions;
      for (let i = pos.length - 1; i >= 3; i -= 3) {
        pos[i] = pos[i - 3];
        pos[i - 1] = pos[i - 4];
        pos[i - 2] = pos[i - 5];
      }
      pos[0] = comet.position.x;
      pos[1] = comet.position.y;
      pos[2] = comet.position.z;
      comet.trailGeometry.attributes.position.needsUpdate = true;
    }

    function createImpactFlash(position, color) {
      const flash = new THREE.Mesh(
        new THREE.SphereGeometry(3, 16, 16),
        new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 })
      );
      flash.position.copy(position);
      scene.add(flash);
      impactFlares.push({ mesh: flash, life: 1.2 });
    }

    function updateFlares(dt) {
      for (let i = impactFlares.length - 1; i >= 0; i--) {
        const flare = impactFlares[i];
        flare.life -= dt * 0.8;
        flare.mesh.scale.addScalar(dt * 0.8);
        flare.mesh.material.opacity = Math.max(flare.life / 1.2, 0);
        if (flare.life <= 0) {
          scene.remove(flare.mesh);
          flare.mesh.geometry.dispose();
          flare.mesh.material.dispose();
          impactFlares.splice(i, 1);
        }
      }
    }

    function disposeComet(comet) {
      scene.remove(comet.mesh);
      scene.remove(comet.trailLine);
      comet.mesh.geometry.dispose();
      comet.mesh.material.dispose();
      comet.trailGeometry.dispose();
      comet.trailLine.material.dispose();
    }

    function updateComets(dt) {
      cometSpawnTimer -= dt;
      if (cometSpawnTimer <= 0 && comets.length < MAX_COMETS) {
        spawnComet();
        cometSpawnTimer = THREE.MathUtils.randFloat(COMET_MIN_DELAY, COMET_MAX_DELAY);
      }

      for (let i = comets.length - 1; i >= 0; i--) {
        const comet = comets[i];
        let acceleration = computeGravity(sun.position, comet.position, SUN_MASS);
        for (const state of planetStates) {
          const dir = new THREE.Vector3().copy(state.position).sub(comet.position);
          const distSq = Math.max(dir.lengthSq(), 9);
          const grav = dir.multiplyScalar((G * state.mass * 4000) / Math.pow(distSq, 1.5));
          acceleration.add(grav);
          if (Math.sqrt(distSq) < state.cfg.size + 1.8) {
            comet.alive = false;
            createImpactFlash(state.position, state.cfg.color);
            break;
          }
        }

        comet.velocity.addScaledVector(acceleration, dt);
        comet.position.addScaledVector(comet.velocity, dt);
        comet.mesh.position.copy(comet.position);
        updateCometTrail(comet);

        if (!comet.alive || comet.position.length() > COMET_MAX_DISTANCE) {
          disposeComet(comet);
          comets.splice(i, 1);
        }
      }
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(clock.getDelta(), 0.05);
      const dt = delta * TIME_ACCEL;
      simTime += dt;

      updatePlanets(dt);
      updateMoon(dt);
      updateComets(dt);
      updateFlares(dt);

      sun.rotation.y += 0.0025 * dt;
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      const { innerWidth, innerHeight } = window;
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
