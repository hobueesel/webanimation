<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Audio Dancing Elves (FFT)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            overflow-x: hidden;
        }

        .page-title {
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 5s ease infinite;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 5s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .instructions {
            max-width: 720px;
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instructions p {
            margin: 0.5rem 0;
            color: #aaa;
            font-size: 0.9rem;
        }

        .instructions ol {
            text-align: left;
            margin: 1rem 2rem;
            color: #ccc;
        }

        .instructions li {
            margin: 0.5rem 0;
        }

        #captureBtn {
            padding: 1rem 2.5rem;
            font-size: 1.2rem;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            margin-bottom: 1rem;
        }

        #captureBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        #captureBtn:active {
            transform: translateY(0);
        }

        #captureBtn.capturing {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        #stopBtn {
            padding: 0.8rem 2rem;
            font-size: 1rem;
            background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1.5rem;
            display: none;
        }

        #stopBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(245, 87, 108, 0.6);
        }

        #status {
            margin-bottom: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .status-idle { background: rgba(255, 255, 255, 0.1); }
        .status-capturing { background: rgba(78, 205, 196, 0.3); color: #4ecdc4; }
        .status-error { background: rgba(255, 107, 107, 0.3); color: #ff6b6b; }

        .canvas-container {
            position: relative;
            width: 90vw;
            max-width: 1200px;
            height: 55vh;
            min-height: 420px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #visualizer {
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.8rem 1.2rem;
            border-radius: 10px;
        }

        .control-group label {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.3rem;
        }

        .control-group select,
        .control-group input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            width: 140px;
        }

        .freq-info {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem 1.5rem;
            border-radius: 20px;
            font-size: 0.8rem;
            user-select: none;
        }

        .freq-info span {
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div class="page-title">GPT-5.2</div>
    <h1>üéµ Dancing Elves (FFT)</h1>

    <div class="instructions">
        <p><strong>How to use:</strong></p>
        <ol>
            <li>Open YouTube in another tab and play a video</li>
            <li>Click "Capture YouTube Audio" below</li>
            <li><strong>Chrome/Edge (recommended):</strong> Click "Chrome Tab" / "Edge Tab", select the YouTube tab, check ‚òëÔ∏è "Share tab audio"</li>
            <li><strong>Firefox:</strong> Window sharing audio support is limited/inconsistent</li>
            <li>Watch the elves dance: <em>bass = bounce</em>, <em>mid = arms</em>, <em>treble = head</em></li>
        </ol>
        <p style="color: #ff6b6b; margin-top: 0.75rem;"><strong>Note:</strong> `getDisplayMedia` requires video; this page stops the video track immediately and only uses the audio for FFT.</p>
    </div>

    <div id="status" class="status-idle">Ready to capture audio</div>

    <button id="captureBtn">üé§ Capture YouTube Audio</button>
    <button id="stopBtn">‚èπ Stop Capture</button>

    <div class="canvas-container">
        <canvas id="visualizer"></canvas>
        <div class="freq-info">
            <div>Bass: <span id="bassLevel">0</span></div>
            <div>Mid: <span id="midLevel">0</span></div>
            <div>Treble: <span id="trebleLevel">0</span></div>
            <div>Peak: <span id="peakFreq">0 Hz</span></div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Elf Count</label>
            <select id="elfCount">
                <option value="3">3</option>
                <option value="5" selected>5</option>
                <option value="7">7</option>
                <option value="9">9</option>
                <option value="12">12</option>
            </select>
        </div>
        <div class="control-group">
            <label>Dance Intensity</label>
            <input type="range" id="intensity" min="0.2" max="2.5" step="0.05" value="1.2">
        </div>
        <div class="control-group">
            <label>Smoothing</label>
            <input type="range" id="smoothing" min="0" max="0.95" step="0.05" value="0.8">
        </div>
        <div class="control-group">
            <label>FFT Size</label>
            <select id="fftSize">
                <option value="512">512</option>
                <option value="1024" selected>1024</option>
                <option value="2048">2048</option>
                <option value="4096">4096</option>
                <option value="8192">8192</option>
            </select>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        const captureBtn = document.getElementById('captureBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusEl = document.getElementById('status');

        const elfCountSelect = document.getElementById('elfCount');
        const intensitySlider = document.getElementById('intensity');
        const smoothingSlider = document.getElementById('smoothing');
        const fftSizeSelect = document.getElementById('fftSize');

        const bassLevelEl = document.getElementById('bassLevel');
        const midLevelEl = document.getElementById('midLevel');
        const trebleLevelEl = document.getElementById('trebleLevel');
        const peakFreqEl = document.getElementById('peakFreq');

        let audioContext = null;
        let analyser = null;
        let sourceNode = null;
        let mediaStream = null;
        let animationId = null;

        let frequencyData = null;

        // Smoothed energies for nicer motion
        let bassE = 0;
        let midE = 0;
        let trebleE = 0;

        const elves = [];

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            layoutElves();
        });

        function setStatus(message, type = 'idle') {
            statusEl.textContent = message;
            statusEl.className = `status-${type}`;
        }

        function clamp01(v) {
            return Math.max(0, Math.min(1, v));
        }

        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function ensureElves() {
            const count = parseInt(elfCountSelect.value);
            while (elves.length < count) {
                elves.push(createElf(elves.length));
            }
            while (elves.length > count) {
                elves.pop();
            }
            layoutElves();
        }

        function createElf(index) {
            const palette = [
                { suit: '#2ecc71', hat: '#e74c3c', skin: '#f2c9a0' },
                { suit: '#1abc9c', hat: '#9b59b6', skin: '#f2c9a0' },
                { suit: '#3498db', hat: '#e67e22', skin: '#f2c9a0' },
                { suit: '#f1c40f', hat: '#2ecc71', skin: '#f2c9a0' },
                { suit: '#e84393', hat: '#00cec9', skin: '#f2c9a0' },
            ];
            const colors = palette[index % palette.length];

            // Assign each elf a primary band: 0=bass, 1=mid, 2=treble (cycle)
            const band = index % 3;

            return {
                index,
                band,
                x: 0,
                y: 0,
                scale: 1,
                phase: Math.random() * Math.PI * 2,
                phase2: Math.random() * Math.PI * 2,
                colors,
            };
        }

        function layoutElves() {
            const count = elves.length;
            if (count === 0) return;

            const floorY = Math.floor(canvas.height * 0.78);
            const paddingX = 60;
            const usableW = Math.max(1, canvas.width - paddingX * 2);
            for (let i = 0; i < count; i++) {
                const t = (count === 1) ? 0.5 : (i / (count - 1));
                elves[i].x = paddingX + t * usableW;
                elves[i].y = floorY;
                // Slight scale variation
                elves[i].scale = 0.9 + (i % 3) * 0.06;
            }
        }

        function bandEnergyFromBins(lowRatio, highRatio) {
            if (!analyser || !frequencyData) return 0;
            const n = analyser.frequencyBinCount;
            const start = Math.max(0, Math.floor(lowRatio * n));
            const end = Math.min(n, Math.max(start + 1, Math.floor(highRatio * n)));
            let sum = 0;
            for (let i = start; i < end; i++) sum += frequencyData[i];
            const avg = sum / (end - start);
            return clamp01(avg / 255);
        }

        function drawBackground(glow) {
            // Backdrop
            const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
            g.addColorStop(0, '#070812');
            g.addColorStop(0.6, '#0a0a0a');
            g.addColorStop(1, '#050505');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stage lights
            const lightCount = 8;
            for (let i = 0; i < lightCount; i++) {
                const x = ((i + 0.5) / lightCount) * canvas.width;
                const radius = 60 + glow * 140;
                const rg = ctx.createRadialGradient(x, 0, 0, x, 0, radius);
                rg.addColorStop(0, `rgba(78, 205, 196, ${0.10 + glow * 0.25})`);
                rg.addColorStop(1, 'rgba(78, 205, 196, 0)');
                ctx.fillStyle = rg;
                ctx.beginPath();
                ctx.arc(x, 0, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Floor
            const floorY = Math.floor(canvas.height * 0.78);
            ctx.fillStyle = 'rgba(0,0,0,0.45)';
            ctx.fillRect(0, floorY, canvas.width, canvas.height - floorY);

            // Floor line
            ctx.strokeStyle = `rgba(255,255,255,${0.06 + glow * 0.12})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, floorY);
            ctx.lineTo(canvas.width, floorY);
            ctx.stroke();
        }

        function drawElf(elf, bass, mid, treble, dt) {
            const intensity = parseFloat(intensitySlider.value);

            // Per-elf energy: mostly their band, a bit of the rest
            const bandE = elf.band === 0 ? bass : (elf.band === 1 ? mid : treble);
            const other = (bass + mid + treble) / 3;
            const e = clamp01(lerp(other, bandE, 0.75)) * intensity;

            // Update phases
            const baseSpeed = 2.2;
            const speed = baseSpeed + e * 6.0;
            elf.phase += dt * speed;
            elf.phase2 += dt * (speed * 0.65 + 0.6);

            const bounce = Math.sin(elf.phase) * (14 + e * 26);
            const sway = Math.sin(elf.phase2) * (6 + e * 10);
            const headWiggle = Math.sin(elf.phase * 1.7) * (2 + treble * intensity * 7);
            const armSwing = Math.sin(elf.phase * 1.3) * (0.6 + mid * intensity * 1.5);

            const x = elf.x + sway;
            const y = elf.y - Math.max(0, bounce);
            const s = elf.scale;

            // Sizes (scaled)
            const headR = 14 * s;
            const bodyH = 44 * s;
            const bodyW = 22 * s;
            const legL = 26 * s;
            const armL = 26 * s;

            // Shadow
            ctx.fillStyle = `rgba(0,0,0,${0.25 + e * 0.1})`;
            ctx.beginPath();
            ctx.ellipse(elf.x, elf.y + 8, 24 * s + e * 6, 8 * s, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body (suit)
            ctx.save();
            ctx.translate(x, y);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Glow for high energy
            ctx.shadowColor = elf.colors.hat;
            ctx.shadowBlur = 8 * e;

            // Torso
            ctx.fillStyle = elf.colors.suit;
            ctx.beginPath();
            ctx.roundRect(-bodyW / 2, -bodyH, bodyW, bodyH, 6 * s);
            ctx.fill();

            // Belt
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(-bodyW / 2, -bodyH * 0.55, bodyW, 6 * s);
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(-bodyW / 2, -bodyH * 0.75, bodyW, 2 * s);

            // Head
            ctx.shadowBlur = 0;
            ctx.fillStyle = elf.colors.skin;
            ctx.beginPath();
            ctx.arc(headWiggle, -bodyH - headR - 4 * s, headR, 0, Math.PI * 2);
            ctx.fill();

            // Ears
            ctx.fillStyle = elf.colors.skin;
            ctx.beginPath();
            ctx.ellipse(-headR - 3 * s + headWiggle, -bodyH - headR - 4 * s, 8 * s, 5 * s, -0.4, 0, Math.PI * 2);
            ctx.ellipse(headR + 3 * s + headWiggle, -bodyH - headR - 4 * s, 8 * s, 5 * s, 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            ctx.fillStyle = 'rgba(0,0,0,0.65)';
            const eyeY = -bodyH - headR - 6 * s;
            ctx.beginPath();
            ctx.arc(-5 * s + headWiggle, eyeY, 2 * s, 0, Math.PI * 2);
            ctx.arc(5 * s + headWiggle, eyeY, 2 * s, 0, Math.PI * 2);
            ctx.fill();

            // Smile
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(headWiggle, eyeY + 10 * s, 6 * s, 0.1 * Math.PI, 0.9 * Math.PI);
            ctx.stroke();

            // Hat
            ctx.fillStyle = elf.colors.hat;
            ctx.beginPath();
            ctx.moveTo(headWiggle - headR, -bodyH - headR - 10 * s);
            ctx.lineTo(headWiggle + headR, -bodyH - headR - 10 * s);
            ctx.lineTo(headWiggle + (headWiggle > 0 ? 18 : -18) * s, -bodyH - headR - 46 * s);
            ctx.closePath();
            ctx.fill();

            // Hat pom
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.beginPath();
            ctx.arc(headWiggle + (headWiggle > 0 ? 18 : -18) * s, -bodyH - headR - 46 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();

            // Arms (mid energy)
            ctx.strokeStyle = elf.colors.suit;
            ctx.lineWidth = 6 * s;

            // Left arm
            ctx.save();
            ctx.translate(-bodyW / 2, -bodyH * 0.65);
            ctx.rotate(-0.8 - armSwing);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-armL, 0);
            ctx.stroke();
            ctx.restore();

            // Right arm
            ctx.save();
            ctx.translate(bodyW / 2, -bodyH * 0.65);
            ctx.rotate(0.8 + armSwing);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(armL, 0);
            ctx.stroke();
            ctx.restore();

            // Hands
            ctx.fillStyle = elf.colors.skin;
            ctx.beginPath();
            ctx.arc(-bodyW / 2 - Math.cos(0.8 + armSwing) * armL, -bodyH * 0.65 - Math.sin(0.8 + armSwing) * armL, 4 * s, 0, Math.PI * 2);
            ctx.arc(bodyW / 2 + Math.cos(0.8 + armSwing) * armL, -bodyH * 0.65 + Math.sin(0.8 + armSwing) * armL, 4 * s, 0, Math.PI * 2);
            ctx.fill();

            // Legs (bass bounce)
            const legSwing = Math.sin(elf.phase * 1.1) * (0.5 + bass * intensity * 1.3);
            ctx.strokeStyle = elf.colors.suit;
            ctx.lineWidth = 7 * s;

            // Left leg
            ctx.save();
            ctx.translate(-bodyW * 0.22, 0);
            ctx.rotate(0.25 + legSwing);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, legL);
            ctx.stroke();
            ctx.restore();

            // Right leg
            ctx.save();
            ctx.translate(bodyW * 0.22, 0);
            ctx.rotate(-0.25 - legSwing);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, legL);
            ctx.stroke();
            ctx.restore();

            // Shoes
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.beginPath();
            ctx.roundRect(-bodyW * 0.55, legL - 2 * s, bodyW * 0.5, 8 * s, 4 * s);
            ctx.roundRect(bodyW * 0.05, legL - 2 * s, bodyW * 0.5, 8 * s, 4 * s);
            ctx.fill();

            // Little band badge
            const badge = elf.band === 0 ? 'B' : (elf.band === 1 ? 'M' : 'T');
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.font = `${10 * s}px monospace`;
            ctx.textAlign = 'center';
            ctx.fillText(badge, 0, -bodyH * 0.35);

            ctx.restore();
        }

        function stopCapture() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            if (sourceNode) {
                sourceNode.disconnect();
                sourceNode = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            analyser = null;

            captureBtn.classList.remove('capturing');
            captureBtn.textContent = 'üé§ Capture YouTube Audio';
            stopBtn.style.display = 'none';
            setStatus('Ready to capture audio', 'idle');

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
            ctx.font = '18px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('Click "Capture YouTube Audio" to start', canvas.width / 2, canvas.height / 2);
        }

        async function captureAudio() {
            try {
                setStatus('Requesting tab audio...', 'idle');

                mediaStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        displaySurface: "browser"
                    },
                    audio: {
                        suppressLocalAudioPlayback: false,
                        autoGainControl: false,
                        echoCancellation: false,
                        noiseSuppression: false
                    },
                    preferCurrentTab: false,
                    selfBrowserSurface: "exclude",
                    systemAudio: "include"
                });

                // Stop video track immediately; we only use audio
                mediaStream.getVideoTracks().forEach(track => track.stop());

                const audioTracks = mediaStream.getAudioTracks();
                if (audioTracks.length === 0) {
                    throw new Error('No audio track captured. Select a TAB and check "Share tab audio" (Chrome/Edge).');
                }

                setStatus(`Capturing: ${audioTracks[0].label}`, 'capturing');

                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                analyser = audioContext.createAnalyser();
                analyser.fftSize = parseInt(fftSizeSelect.value);
                analyser.smoothingTimeConstant = parseFloat(smoothingSlider.value);

                sourceNode = audioContext.createMediaStreamSource(mediaStream);
                sourceNode.connect(analyser);

                frequencyData = new Uint8Array(analyser.frequencyBinCount);

                captureBtn.classList.add('capturing');
                captureBtn.textContent = 'üéµ Capturing...';
                stopBtn.style.display = 'inline-block';

                mediaStream.getAudioTracks()[0].onended = () => {
                    stopCapture();
                };

                // Init elves
                ensureElves();
                layoutElves();

                // Reset energies
                bassE = 0;
                midE = 0;
                trebleE = 0;

                lastT = performance.now();
                visualize();

            } catch (error) {
                console.error('Error capturing audio:', error);
                setStatus(`Error: ${error.message}`, 'error');
            }
        }

        function updateAnalyserSettings() {
            if (analyser) {
                analyser.smoothingTimeConstant = parseFloat(smoothingSlider.value);
            }
        }

        function updateFFTSize() {
            if (analyser && audioContext) {
                analyser.fftSize = parseInt(fftSizeSelect.value);
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
            }
        }

        function updateElfCount() {
            ensureElves();
        }

        let lastT = performance.now();
        function visualize() {
            if (!analyser) return;

            animationId = requestAnimationFrame(visualize);

            analyser.getByteFrequencyData(frequencyData);

            const bufferLength = analyser.frequencyBinCount;
            const bassEnd = Math.floor(bufferLength * 0.1);
            const midEnd = Math.floor(bufferLength * 0.5);

            let bassSum = 0, midSum = 0, trebleSum = 0;
            let peakValue = 0, peakIndex = 0;

            for (let i = 0; i < bufferLength; i++) {
                const value = frequencyData[i];
                if (i < bassEnd) bassSum += value;
                else if (i < midEnd) midSum += value;
                else trebleSum += value;

                if (value > peakValue) {
                    peakValue = value;
                    peakIndex = i;
                }
            }

            const bassLevel = bassSum / bassEnd;
            const midLevel = midSum / (midEnd - bassEnd);
            const trebleLevel = trebleSum / (bufferLength - midEnd);

            bassLevelEl.textContent = Math.round(bassLevel);
            midLevelEl.textContent = Math.round(midLevel);
            trebleLevelEl.textContent = Math.round(trebleLevel);

            const nyquist = audioContext.sampleRate / 2;
            const peakFreq = Math.round((peakIndex / bufferLength) * nyquist);
            peakFreqEl.textContent = `${peakFreq} Hz`;

            // Normalize and smooth energies
            const rawBass = clamp01(bassLevel / 255);
            const rawMid = clamp01(midLevel / 255);
            const rawTreble = clamp01(trebleLevel / 255);

            bassE = lerp(bassE, rawBass, 0.18);
            midE = lerp(midE, rawMid, 0.18);
            trebleE = lerp(trebleE, rawTreble, 0.18);

            const now = performance.now();
            const dt = Math.min(0.05, (now - lastT) / 1000);
            lastT = now;

            const glow = clamp01((bassE * 0.55 + midE * 0.35 + trebleE * 0.25) * parseFloat(intensitySlider.value) * 0.9);
            drawBackground(glow);

            // Draw elves
            ensureElves();
            for (const elf of elves) {
                drawElf(elf, bassE, midE, trebleE, dt);
            }

            // Subtle on-stage "equalizer" pixels behind elves (still elf-focused)
            drawStagePixels(glow);
        }

        function drawStagePixels(glow) {
            const floorY = Math.floor(canvas.height * 0.78);
            const cols = 40;
            const rows = 10;
            const cellW = canvas.width / cols;
            const cellH = (canvas.height - floorY) / rows;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const x = c * cellW;
                    const y = floorY + r * cellH;
                    const band = c / cols;
                    const e = lerp(bassE, trebleE, band);
                    const chance = (0.05 + glow * 0.18) + e * 0.10;
                    if (Math.random() < chance) {
                        const a = 0.06 + glow * 0.18;
                        ctx.fillStyle = `rgba(78, 205, 196, ${a})`;
                        ctx.fillRect(x + 1, y + 1, Math.max(1, cellW - 2), Math.max(1, cellH - 2));
                    }
                }
            }
        }

        // Events
        captureBtn.addEventListener('click', captureAudio);
        stopBtn.addEventListener('click', stopCapture);
        smoothingSlider.addEventListener('input', updateAnalyserSettings);
        fftSizeSelect.addEventListener('change', updateFFTSize);
        elfCountSelect.addEventListener('change', updateElfCount);

        // Initial state
        ensureElves();
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
        ctx.font = '18px Segoe UI';
        ctx.textAlign = 'center';
        ctx.fillText('Click "Capture YouTube Audio" to start', canvas.width / 2, canvas.height / 2);
    </script>
</body>
</html>
