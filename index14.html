<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epic 3D Battle: 100 Chickens vs 3 Cows</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }

        #canvas {
            display: block;
        }

        #stats {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            font-size: 18px;
        }

        #stats h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .team-stats {
            display: flex;
            justify-content: space-around;
            gap: 40px;
        }

        .chicken-stats { color: #ffcc00; }
        .cow-stats { color: #ff6b6b; }

        #winner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffd700;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            z-index: 2000;
            display: none;
            font-size: 32px;
            border: 3px solid #ffd700;
        }

        #winner button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            background: #ffd700;
            border: none;
            border-radius: 10px;
            font-weight: bold;
        }

        #winner button:hover {
            background: #ffec8b;
        }

        #battle-log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 200px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 10px;
            overflow-y: auto;
            font-size: 12px;
            z-index: 1000;
        }

        #battle-log h3 {
            color: #ffd700;
            margin-bottom: 5px;
        }

        .log-entry {
            margin: 3px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .log-chicken { background: rgba(255, 204, 0, 0.3); }
        .log-cow { background: rgba(255, 107, 107, 0.3); }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="stats">
        <h1>‚öîÔ∏è Epic 3D Battle ‚öîÔ∏è</h1>
        <div class="team-stats">
            <div class="chicken-stats">
                üêî Chickens: <span id="chicken-count">100</span>
            </div>
            <div class="cow-stats">
                üêÑ Cows: <span id="cow-count">3</span>
            </div>
        </div>
    </div>

    <div id="battle-log">
        <h3>üìú Battle Log</h3>
        <div id="log-entries"></div>
    </div>

    <div id="controls">
        üñ±Ô∏è Drag to rotate | Scroll to zoom
    </div>

    <div id="skills-info" style="position: fixed; top: 100px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; z-index: 1000; font-size: 12px;">
        <h3 style="color: #ffd700; margin-bottom: 10px;">‚ö° Special Skills</h3>
        <div style="margin-bottom: 8px;">
            <b style="color: #ffcc00;">üêî Chickens:</b><br>
            ‚ö° <span style="color: #00ffff;">Peck Flurry</span> - Quick 3-hit combo<br>
            üí• <span style="color: #ff00ff;">Egg Bomb</span> - Charged AOE explosion
        </div>
        <div>
            <b style="color: #ff6b6b;">üêÑ Cows:</b><br>
            ‚ö° <span style="color: #00ff00;">Tail Whip</span> - Quick sweep attack<br>
            üí• <span style="color: #ff4400;">MOO-CLEAR BLAST</span> - Devastating charge attack
        </div>
    </div>

    <div id="ml-panel" style="position: fixed; top: 100px; right: 20px; background: rgba(0,0,0,0.85); color: white; padding: 15px; border-radius: 10px; z-index: 1000; font-size: 12px; width: 280px; border: 1px solid #4a90d9;">
        <h3 style="color: #4a90d9; margin-bottom: 10px;">ü§ñ ML Auto-Balance</h3>
        <div style="margin-bottom: 8px;">
            <b>Battle History:</b><br>
            üêî Chicken Wins: <span id="ml-chicken-wins">0</span><br>
            üêÑ Cow Wins: <span id="ml-cow-wins">0</span><br>
            üìä Win Rate: <span id="ml-winrate">50%</span> chickens
        </div>
        <div style="margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 5px;">
            <b>Current Multipliers:</b><br>
            üêî Chicken Power: <span id="ml-chicken-mult">1.00</span>x<br>
            üêÑ Cow Power: <span id="ml-cow-mult">1.00</span>x
        </div>
        <div style="margin-bottom: 8px;">
            <b>Learning Rate:</b> <span id="ml-lr">0.05</span><br>
            <b>Target:</b> 50% win rate each
        </div>
        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
            <button onclick="mlBalance.reset()" style="padding: 5px 10px; cursor: pointer; background: #ff6b6b; border: none; border-radius: 5px; color: white; font-size: 11px;">Reset ML</button>
            <button onclick="runAutoBalance(10)" style="padding: 5px 10px; cursor: pointer; background: #4a90d9; border: none; border-radius: 5px; color: white; font-size: 11px;">Auto 10x</button>
            <button onclick="toggleAutoPlay()" style="padding: 5px 10px; cursor: pointer; background: #50c878; border: none; border-radius: 5px; color: white; font-size: 11px;" id="auto-play-btn">‚ñ∂ Auto-Play</button>
        </div>
        <div style="margin-top: 8px; font-size: 10px; color: #888;">
            ML adjusts balance after each battle to achieve 50/50 win rate.
        </div>
    </div>

    <div id="winner">
        <div id="winner-text"></div>
        <button onclick="restartBattle()">üîÑ Restart Battle</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 60);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a7c23,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add some grass tufts
        for (let i = 0; i < 500; i++) {
            const grassGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
            const grassMaterial = new THREE.MeshStandardMaterial({ color: 0x3d6b1e });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.position.set(
                (Math.random() - 0.5) * 180,
                0.25,
                (Math.random() - 0.5) * 180
            );
            scene.add(grass);
        }

        // UI Elements
        const chickenCountEl = document.getElementById('chicken-count');
        const cowCountEl = document.getElementById('cow-count');
        const winnerEl = document.getElementById('winner');
        const winnerTextEl = document.getElementById('winner-text');
        const logEntries = document.getElementById('log-entries');

        // Game state
        let chickens = [];
        let cows = [];
        let battleActive = true;
        let particles = [];
        let autoPlayEnabled = false;
        let autoBalanceRemaining = 0;

        // ==========================================
        // ML AUTO-BALANCE SYSTEM
        // ==========================================
        const mlBalance = {
            // Base stats (before multipliers)
            baseStats: {
                chicken: { hp: 10, damage: 2, speed: 0.15 },
                cow: { hp: 200, damage: 18, speed: 0.1 }
            },
            
            // Learned multipliers
            chickenMult: 1.0,
            cowMult: 1.0,
            
            // Battle history
            chickenWins: 0,
            cowWins: 0,
            recentResults: [], // Last N results for moving average
            maxHistory: 20,
            
            // Learning parameters
            learningRate: 0.05,
            minMult: 0.5,
            maxMult: 2.0,
            
            // Load from localStorage
            load() {
                try {
                    const saved = localStorage.getItem('chickenCowML');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.chickenMult = data.chickenMult || 1.0;
                        this.cowMult = data.cowMult || 1.0;
                        this.chickenWins = data.chickenWins || 0;
                        this.cowWins = data.cowWins || 0;
                        this.recentResults = data.recentResults || [];
                        console.log('ML state loaded:', data);
                    }
                } catch (e) {
                    console.log('No saved ML state found');
                }
                this.updateUI();
            },
            
            // Save to localStorage
            save() {
                const data = {
                    chickenMult: this.chickenMult,
                    cowMult: this.cowMult,
                    chickenWins: this.chickenWins,
                    cowWins: this.cowWins,
                    recentResults: this.recentResults
                };
                localStorage.setItem('chickenCowML', JSON.stringify(data));
            },
            
            // Record battle result and learn
            recordResult(winner) {
                // Update counters
                if (winner === 'chicken') {
                    this.chickenWins++;
                    this.recentResults.push(1); // 1 = chicken win
                } else {
                    this.cowWins++;
                    this.recentResults.push(0); // 0 = cow win
                }
                
                // Keep only recent history
                if (this.recentResults.length > this.maxHistory) {
                    this.recentResults.shift();
                }
                
                // Learn from result using gradient descent
                this.learn();
                
                // Save state
                this.save();
                this.updateUI();
            },
            
            // Simple gradient descent learning
            learn() {
                if (this.recentResults.length < 3) return; // Need some history
                
                // Calculate recent win rate for chickens
                const recentChickenWinRate = this.recentResults.reduce((a, b) => a + b, 0) / this.recentResults.length;
                
                // Target is 0.5 (50% win rate)
                const error = recentChickenWinRate - 0.5;
                
                // Adjust multipliers based on error
                // If chickens winning too much (error > 0), reduce chicken power OR increase cow power
                // If cows winning too much (error < 0), increase chicken power OR reduce cow power
                
                const adjustment = error * this.learningRate;
                
                // We'll adjust both sides in opposite directions for faster convergence
                this.chickenMult -= adjustment;
                this.cowMult += adjustment;
                
                // Clamp to reasonable bounds
                this.chickenMult = Math.max(this.minMult, Math.min(this.maxMult, this.chickenMult));
                this.cowMult = Math.max(this.minMult, Math.min(this.maxMult, this.cowMult));
                
                console.log(`ML Learn: error=${error.toFixed(3)}, chickenMult=${this.chickenMult.toFixed(3)}, cowMult=${this.cowMult.toFixed(3)}`);
            },
            
            // Get current stats with multipliers applied
            getChickenStats() {
                return {
                    hp: Math.round(this.baseStats.chicken.hp * this.chickenMult),
                    damage: Math.round(this.baseStats.chicken.damage * this.chickenMult * 10) / 10,
                    speed: this.baseStats.chicken.speed * Math.sqrt(this.chickenMult)
                };
            },
            
            getCowStats() {
                return {
                    hp: Math.round(this.baseStats.cow.hp * this.cowMult),
                    damage: Math.round(this.baseStats.cow.damage * this.cowMult * 10) / 10,
                    speed: this.baseStats.cow.speed * Math.sqrt(this.cowMult)
                };
            },
            
            // Reset all learned data
            reset() {
                this.chickenMult = 1.0;
                this.cowMult = 1.0;
                this.chickenWins = 0;
                this.cowWins = 0;
                this.recentResults = [];
                localStorage.removeItem('chickenCowML');
                this.updateUI();
                addLogEntry('ü§ñ ML balance reset!', 'chicken');
            },
            
            // Update UI display
            updateUI() {
                document.getElementById('ml-chicken-wins').textContent = this.chickenWins;
                document.getElementById('ml-cow-wins').textContent = this.cowWins;
                document.getElementById('ml-chicken-mult').textContent = this.chickenMult.toFixed(2);
                document.getElementById('ml-cow-mult').textContent = this.cowMult.toFixed(2);
                document.getElementById('ml-lr').textContent = this.learningRate.toFixed(2);
                
                const total = this.chickenWins + this.cowWins;
                const winRate = total > 0 ? (this.chickenWins / total * 100).toFixed(1) : '50.0';
                document.getElementById('ml-winrate').textContent = winRate + '%';
            }
        };
        
        // Load ML state on startup
        mlBalance.load();
        
        // Auto-play functionality
        function toggleAutoPlay() {
            autoPlayEnabled = !autoPlayEnabled;
            const btn = document.getElementById('auto-play-btn');
            btn.textContent = autoPlayEnabled ? '‚è∏ Stop' : '‚ñ∂ Auto-Play';
            btn.style.background = autoPlayEnabled ? '#ff6b6b' : '#50c878';
            
            if (autoPlayEnabled && !battleActive) {
                restartBattle();
            }
        }
        
        function runAutoBalance(count) {
            autoBalanceRemaining = count;
            if (!battleActive) {
                restartBattle();
            }
            addLogEntry(`ü§ñ Running ${count} auto-balance battles...`, 'chicken');
        }
        
        // Dynamic stats that use ML multipliers
        function getChickenHP() { return mlBalance.getChickenStats().hp; }
        function getChickenDamage() { return mlBalance.getChickenStats().damage; }
        function getChickenSpeed() { return mlBalance.getChickenStats().speed; }
        function getCowHP() { return mlBalance.getCowStats().hp; }
        function getCowDamage() { return mlBalance.getCowStats().damage; }
        function getCowSpeed() { return mlBalance.getCowStats().speed; }

        const FIELD_SIZE = 80;

        // Special skill effects
        let skillEffects = [];

        // Create skill charging visual
        function createChargingEffect(x, y, z, color, scale = 1) {
            const group = new THREE.Group();
            
            // Glowing ring
            const ringGeometry = new THREE.RingGeometry(0.5 * scale, 0.8 * scale, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            group.add(ring);
            
            // Particles rising
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1 * scale, 6, 6);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: color });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                const angle = (i / 8) * Math.PI * 2;
                particle.position.set(Math.cos(angle) * 0.6 * scale, 0, Math.sin(angle) * 0.6 * scale);
                particle.userData = { angle, speed: 0.05 + Math.random() * 0.05 };
                group.add(particle);
            }
            
            group.position.set(x, y, z);
            scene.add(group);
            
            return {
                mesh: group,
                life: 2,
                update: function(dt) {
                    this.life -= dt;
                    // Rotate ring
                    group.children[0].rotation.z += 0.1;
                    // Scale up
                    const scale = 1 + (2 - this.life) * 0.5;
                    group.children[0].scale.set(scale, scale, 1);
                    // Animate particles
                    for (let i = 1; i < group.children.length; i++) {
                        const p = group.children[i];
                        p.position.y += p.userData.speed;
                        p.userData.angle += 0.1;
                        p.position.x = Math.cos(p.userData.angle) * 0.6 * scale;
                        p.position.z = Math.sin(p.userData.angle) * 0.6 * scale;
                    }
                    return this.life > 0;
                }
            };
        }

        // Explosion effect for ultimate skills
        function createExplosionEffect(x, y, z, color, radius, damage, sourceType) {
            const group = new THREE.Group();
            
            // Expanding sphere
            const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            group.add(sphere);
            
            // Shockwave ring
            const shockGeometry = new THREE.RingGeometry(0.1, 0.5, 32);
            const shockMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const shockwave = new THREE.Mesh(shockGeometry, shockMaterial);
            shockwave.rotation.x = -Math.PI / 2;
            group.add(shockwave);
            
            // Debris particles
            for (let i = 0; i < 20; i++) {
                const debrisGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const debrisMaterial = new THREE.MeshBasicMaterial({ color: color });
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.4 + 0.2,
                        (Math.random() - 0.5) * 0.5
                    )
                };
                group.add(debris);
            }
            
            group.position.set(x, y, z);
            scene.add(group);
            
            // Deal damage to enemies in radius
            const enemies = sourceType === 'chicken' ? cows : chickens;
            enemies.forEach(enemy => {
                if (!enemy.alive) return;
                const dx = enemy.x - x;
                const dz = enemy.z - z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < radius) {
                    const falloff = 1 - (dist / radius) * 0.5;
                    enemy.takeDamage(Math.round(damage * falloff), null);
                }
            });
            
            return {
                mesh: group,
                life: 1.5,
                maxRadius: radius,
                update: function(dt) {
                    this.life -= dt;
                    const progress = 1 - (this.life / 1.5);
                    
                    // Expand sphere
                    const sphereScale = progress * this.maxRadius * 2;
                    group.children[0].scale.set(sphereScale, sphereScale, sphereScale);
                    group.children[0].material.opacity = 0.6 * (1 - progress);
                    
                    // Expand shockwave
                    const shockScale = progress * this.maxRadius * 3;
                    group.children[1].scale.set(shockScale, shockScale, 1);
                    group.children[1].material.opacity = 0.8 * (1 - progress);
                    
                    // Animate debris
                    for (let i = 2; i < group.children.length; i++) {
                        const debris = group.children[i];
                        debris.position.add(debris.userData.velocity);
                        debris.userData.velocity.y -= 0.02;
                        debris.rotation.x += 0.1;
                        debris.rotation.z += 0.1;
                    }
                    
                    return this.life > 0;
                }
            };
        }

        // Quick attack effect (slashes/hits)
        function createQuickAttackEffect(x, y, z, color, count = 3) {
            const group = new THREE.Group();
            
            for (let i = 0; i < count; i++) {
                const slashGeometry = new THREE.PlaneGeometry(0.8, 0.2);
                const slashMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const slash = new THREE.Mesh(slashGeometry, slashMaterial);
                slash.rotation.z = (Math.random() - 0.5) * Math.PI;
                slash.rotation.y = Math.random() * Math.PI;
                slash.position.set(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5 + 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                slash.userData = { delay: i * 0.1 };
                group.add(slash);
            }
            
            group.position.set(x, y, z);
            scene.add(group);
            
            return {
                mesh: group,
                life: 0.5,
                update: function(dt) {
                    this.life -= dt;
                    const progress = 1 - (this.life / 0.5);
                    
                    group.children.forEach((slash, i) => {
                        const localProgress = Math.max(0, Math.min(1, (progress - slash.userData.delay * 2) * 3));
                        slash.scale.set(localProgress * 2, 1 + localProgress, 1);
                        slash.material.opacity = 0.9 * (1 - localProgress);
                    });
                    
                    return this.life > 0;
                }
            };
        }

        // Tail whip sweep effect
        function createSweepEffect(x, y, z, direction, color) {
            const group = new THREE.Group();
            
            // Arc sweep
            const arcGeometry = new THREE.TorusGeometry(2, 0.1, 8, 32, Math.PI);
            const arcMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const arc = new THREE.Mesh(arcGeometry, arcMaterial);
            arc.rotation.x = -Math.PI / 2;
            arc.rotation.z = direction;
            group.add(arc);
            
            // Trail particles
            for (let i = 0; i < 10; i++) {
                const trailGeometry = new THREE.SphereGeometry(0.15, 6, 6);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                const angle = (i / 10) * Math.PI + direction;
                trail.position.set(Math.cos(angle) * 2, 0.5, Math.sin(angle) * 2);
                group.add(trail);
            }
            
            group.position.set(x, y, z);
            scene.add(group);
            
            return {
                mesh: group,
                life: 0.4,
                update: function(dt) {
                    this.life -= dt;
                    const progress = 1 - (this.life / 0.4);
                    
                    // Expand and fade arc
                    group.children[0].scale.set(1 + progress * 0.5, 1 + progress * 0.5, 1);
                    group.children[0].material.opacity = 0.8 * (1 - progress);
                    
                    // Fade trail
                    for (let i = 1; i < group.children.length; i++) {
                        group.children[i].material.opacity = 0.6 * (1 - progress);
                    }
                    
                    return this.life > 0;
                }
            };
        }

        // MOO-CLEAR charge up effect
        function createMooClearChargeEffect(entity) {
            const group = new THREE.Group();
            
            // Multiple rotating rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(2 + i * 0.5, 0.15, 8, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff4400,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.userData = { rotSpeed: 0.05 * (i + 1), axis: i % 2 === 0 ? 'x' : 'z' };
                group.add(ring);
            }
            
            // Energy orbs gathering
            for (let i = 0; i < 12; i++) {
                const orbGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                const orbMaterial = new THREE.MeshBasicMaterial({ 
                    color: i % 2 === 0 ? 0xff4400 : 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                const angle = (i / 12) * Math.PI * 2;
                orb.userData = { angle, radius: 5, targetRadius: 0.5 };
                orb.position.set(Math.cos(angle) * 5, 1.5, Math.sin(angle) * 5);
                group.add(orb);
            }
            
            group.position.set(entity.x, 0, entity.z);
            scene.add(group);
            
            return {
                mesh: group,
                entity: entity,
                life: 1.5,
                update: function(dt) {
                    this.life -= dt;
                    const progress = 1 - (this.life / 1.5);
                    
                    // Update position to follow entity
                    group.position.set(this.entity.x, 0, this.entity.z);
                    
                    // Rotate rings
                    for (let i = 0; i < 3; i++) {
                        const ring = group.children[i];
                        if (ring.userData.axis === 'x') {
                            ring.rotation.x += ring.userData.rotSpeed;
                        } else {
                            ring.rotation.z += ring.userData.rotSpeed;
                        }
                        ring.rotation.y += 0.02;
                        // Scale up rings
                        const scale = 0.5 + progress * 1.5;
                        ring.scale.set(scale, scale, scale);
                        ring.material.opacity = 0.7 + progress * 0.3;
                    }
                    
                    // Orbs gathering inward
                    for (let i = 3; i < group.children.length; i++) {
                        const orb = group.children[i];
                        orb.userData.radius = 5 * (1 - progress * 0.9);
                        orb.userData.angle += 0.1;
                        orb.position.set(
                            Math.cos(orb.userData.angle) * orb.userData.radius,
                            1.5 + Math.sin(orb.userData.angle * 2) * 0.5,
                            Math.sin(orb.userData.angle) * orb.userData.radius
                        );
                        orb.scale.setScalar(1 + progress);
                    }
                    
                    return this.life > 0;
                }
            };
        }

        // Create chicken mesh
        function createChickenMesh() {
            const group = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.3, 0.9, 0);
            head.castShadow = true;
            group.add(head);

            // Beak
            const beakGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
            const beakMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500 });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0.55, 0.85, 0);
            beak.rotation.z = -Math.PI / 2;
            group.add(beak);

            // Comb
            const combGeometry = new THREE.BoxGeometry(0.15, 0.2, 0.05);
            const combMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const comb = new THREE.Mesh(combGeometry, combMaterial);
            comb.position.set(0.3, 1.15, 0);
            group.add(comb);

            // Wattle
            const wattleGeometry = new THREE.SphereGeometry(0.08, 6, 6);
            const wattleMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const wattle = new THREE.Mesh(wattleGeometry, wattleMaterial);
            wattle.position.set(0.45, 0.7, 0);
            group.add(wattle);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0xffa500 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0, 0.15, 0.15);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0, 0.15, -0.15);
            group.add(rightLeg);

            // Tail feathers
            const tailGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.5, 0.7, 0);
            tail.rotation.z = Math.PI / 3;
            group.add(tail);

            // Wings
            const wingGeometry = new THREE.SphereGeometry(0.25, 6, 6);
            wingGeometry.scale(1, 0.5, 0.3);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(0, 0.5, 0.35);
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0, 0.5, -0.35);
            group.add(rightWing);

            return group;
        }

        // Create cow mesh
        function createCowMesh() {
            const group = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(3, 1.5, 1.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.5;
            body.castShadow = true;
            group.add(body);

            // Spots
            const spotGeometry = new THREE.CircleGeometry(0.3, 8);
            const spotMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });
            
            for (let i = 0; i < 5; i++) {
                const spot = new THREE.Mesh(spotGeometry, spotMaterial);
                spot.position.set(
                    (Math.random() - 0.5) * 2,
                    1.5 + (Math.random() - 0.5) * 0.5,
                    0.76 * (Math.random() > 0.5 ? 1 : -1)
                );
                spot.rotation.y = Math.PI / 2 * (spot.position.z > 0 ? 0 : 1);
                group.add(spot);
            }

            // Head
            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(1.8, 1.8, 0);
            head.castShadow = true;
            group.add(head);

            // Snout
            const snoutGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.5);
            const snoutMaterial = new THREE.MeshStandardMaterial({ color: 0xffcccc });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(2.2, 1.6, 0);
            group.add(snout);

            // Nostrils
            const nostrilGeometry = new THREE.CircleGeometry(0.05, 6);
            const nostrilMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide });
            
            const leftNostril = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
            leftNostril.position.set(2.41, 1.6, 0.1);
            leftNostril.rotation.y = Math.PI / 2;
            group.add(leftNostril);

            const rightNostril = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
            rightNostril.position.set(2.41, 1.6, -0.1);
            rightNostril.rotation.y = Math.PI / 2;
            group.add(rightNostril);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.12, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(2.1, 2.0, 0.3);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(2.1, 2.0, -0.3);
            group.add(rightEye);

            // Horns
            const hornGeometry = new THREE.ConeGeometry(0.1, 0.4, 6);
            const hornMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            
            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(1.6, 2.4, 0.3);
            leftHorn.rotation.z = -0.3;
            group.add(leftHorn);

            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(1.6, 2.4, -0.3);
            rightHorn.rotation.z = -0.3;
            group.add(rightHorn);

            // Ears
            const earGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
            const earMaterial = new THREE.MeshStandardMaterial({ color: 0xffcccc });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(1.5, 2.0, 0.5);
            group.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(1.5, 2.0, -0.5);
            group.add(rightEar);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            
            const positions = [
                [1, 0.5, 0.5],
                [1, 0.5, -0.5],
                [-1, 0.5, 0.5],
                [-1, 0.5, -0.5]
            ];

            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                group.add(leg);

                // Hoof
                const hoofGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.1);
                const hoofMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const hoof = new THREE.Mesh(hoofGeometry, hoofMaterial);
                hoof.position.set(pos[0], 0.05, pos[2]);
                group.add(hoof);
            });

            // Tail
            const tailGeometry = new THREE.CylinderGeometry(0.05, 0.03, 1);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-1.8, 1.3, 0);
            tail.rotation.z = Math.PI / 4;
            group.add(tail);

            // Tail tuft
            const tuftGeometry = new THREE.SphereGeometry(0.1, 6, 6);
            const tuftMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const tuft = new THREE.Mesh(tuftGeometry, tuftMaterial);
            tuft.position.set(-2.2, 0.8, 0);
            group.add(tuft);

            // Udder
            const udderGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const udderMaterial = new THREE.MeshStandardMaterial({ color: 0xffcccc });
            const udder = new THREE.Mesh(udderGeometry, udderMaterial);
            udder.position.set(-0.5, 0.7, 0);
            group.add(udder);

            return group;
        }

        // Health bar sprite
        function createHealthBar() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 8;
            const ctx = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2, 0.3, 1);
            
            return { sprite, canvas, ctx, texture };
        }

        function updateHealthBar(healthBar, percent) {
            const { canvas, ctx, texture } = healthBar;
            ctx.clearRect(0, 0, 64, 8);
            
            // Background
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, 64, 8);
            
            // Health
            if (percent > 60) ctx.fillStyle = '#00ff00';
            else if (percent > 30) ctx.fillStyle = '#ffff00';
            else ctx.fillStyle = '#ff0000';
            
            ctx.fillRect(1, 1, 62 * (percent / 100), 6);
            
            texture.needsUpdate = true;
        }

        // Entity class
        class Entity {
            constructor(type, x, z, id) {
                this.type = type;
                this.id = id;
                this.x = x;
                this.z = z;
                
                // Use ML-balanced stats
                if (type === 'chicken') {
                    this.maxHp = getChickenHP();
                    this.damage = getChickenDamage();
                    this.speed = getChickenSpeed();
                } else {
                    this.maxHp = getCowHP();
                    this.damage = getCowDamage();
                    this.speed = getCowSpeed();
                }
                
                this.hp = this.maxHp;
                this.target = null;
                this.attackCooldown = 0;
                this.alive = true;
                this.bobPhase = Math.random() * Math.PI * 2;

                // Special skills
                this.quickSkillCooldown = 0;  // Quick attack skill
                this.ultimateCooldown = Math.random() * 5; // Charged ultimate
                this.isChargingUltimate = false;
                this.ultimateChargeTime = 0;
                this.chargingEffect = null;

                this.createMesh();
            }

            createMesh() {
                if (this.type === 'chicken') {
                    this.mesh = createChickenMesh();
                    this.mesh.scale.set(0.8, 0.8, 0.8);
                } else {
                    this.mesh = createCowMesh();
                    this.mesh.scale.set(1, 1, 1);
                }
                
                this.mesh.position.set(this.x, 0, this.z);
                scene.add(this.mesh);

                // Health bar
                this.healthBar = createHealthBar();
                this.healthBar.sprite.position.y = this.type === 'chicken' ? 2 : 3.5;
                this.mesh.add(this.healthBar.sprite);
                updateHealthBar(this.healthBar, 100);
            }

            update() {
                if (!this.alive) return;

                const dt = 0.016;

                // Reduce cooldowns
                if (this.attackCooldown > 0) this.attackCooldown -= dt;
                if (this.quickSkillCooldown > 0) this.quickSkillCooldown -= dt;
                if (this.ultimateCooldown > 0) this.ultimateCooldown -= dt;

                // Handle ultimate charging
                if (this.isChargingUltimate) {
                    this.ultimateChargeTime += dt;
                    const chargeNeeded = this.type === 'chicken' ? 2 : 1.5;
                    
                    if (this.ultimateChargeTime >= chargeNeeded) {
                        this.releaseUltimate();
                    }
                    
                    // Slow movement while charging
                    this.bobPhase += 0.05;
                    const bobHeight = Math.sin(this.bobPhase) * 0.1 + 0.2;
                    this.mesh.position.set(this.x, bobHeight, this.z);
                    return;
                }

                // Find target
                const enemies = this.type === 'chicken' ? cows : chickens;
                const aliveEnemies = enemies.filter(e => e.alive);

                if (aliveEnemies.length === 0) return;

                // Find nearest enemy
                let nearest = null;
                let nearestDist = Infinity;

                for (const enemy of aliveEnemies) {
                    const dx = enemy.x - this.x;
                    const dz = enemy.z - this.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = enemy;
                    }
                }

                this.target = nearest;

                const attackRange = this.type === 'chicken' ? 2 : 4;
                const quickSkillRange = this.type === 'chicken' ? 2.5 : 5;
                const ultimateRange = this.type === 'chicken' ? 3 : 8;

                // Check for ultimate activation (when multiple enemies nearby for cows, or near a cow for chickens)
                if (this.ultimateCooldown <= 0 && nearestDist < ultimateRange) {
                    if (this.type === 'cow') {
                        // Cow checks if multiple chickens are nearby
                        const nearbyChickens = chickens.filter(c => {
                            if (!c.alive) return false;
                            const dx = c.x - this.x;
                            const dz = c.z - this.z;
                            return Math.sqrt(dx * dx + dz * dz) < 10;
                        }).length;
                        
                        if (nearbyChickens >= 5) {
                            this.startUltimate();
                            return;
                        }
                    } else {
                        // Chicken has 15% chance to use ultimate when near a cow
                        if (Math.random() < 0.004) {
                            this.startUltimate();
                            return;
                        }
                    }
                }

                if (nearestDist < attackRange) {
                    // Try quick skill first
                    if (this.quickSkillCooldown <= 0 && Math.random() < 0.3) {
                        this.useQuickSkill(this.target);
                        this.quickSkillCooldown = this.type === 'chicken' ? 2.5 : 3;
                    }
                    // Normal attack
                    else if (this.attackCooldown <= 0) {
                        this.attack(this.target);
                        this.attackCooldown = this.type === 'chicken' ? 0.5 : 0.8;
                    }
                } else {
                    // Move towards target
                    const dx = this.target.x - this.x;
                    const dz = this.target.z - this.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    // Add some randomness to movement
                    const randomAngle = (Math.random() - 0.5) * 0.3;
                    const cos = Math.cos(randomAngle);
                    const sin = Math.sin(randomAngle);

                    const moveX = ((dx / dist) * cos - (dz / dist) * sin) * this.speed;
                    const moveZ = ((dx / dist) * sin + (dz / dist) * cos) * this.speed;

                    this.x += moveX;
                    this.z += moveZ;

                    // Keep in bounds
                    this.x = Math.max(-FIELD_SIZE, Math.min(FIELD_SIZE, this.x));
                    this.z = Math.max(-FIELD_SIZE, Math.min(FIELD_SIZE, this.z));

                    // Rotate to face direction
                    this.mesh.rotation.y = Math.atan2(moveX, moveZ);
                }

                // Update position with bobbing
                this.bobPhase += 0.1;
                const bobHeight = Math.sin(this.bobPhase) * 0.1;
                this.mesh.position.set(this.x, bobHeight, this.z);
            }

            // Quick skill - fast multi-hit attack
            useQuickSkill(target) {
                if (this.type === 'chicken') {
                    // Peck Flurry - 3 quick hits
                    addLogEntry(`üêî Chicken #${this.id} uses ‚ö°PECK FLURRY!`, 'chicken');
                    skillEffects.push(createQuickAttackEffect(target.x, 1, target.z, 0x00ffff, 3));
                    
                    // Deal 3 hits
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (target.alive && this.alive) {
                                target.takeDamage(Math.round(this.damage * 0.6), this);
                            }
                        }, i * 100);
                    }
                } else {
                    // Tail Whip - sweep attack hitting multiple targets
                    addLogEntry(`üêÑ Cow #${this.id} uses ‚ö°TAIL WHIP!`, 'cow');
                    skillEffects.push(createSweepEffect(this.x, 0.5, this.z, this.mesh.rotation.y, 0x00ff00));
                    
                    // Hit all chickens in range
                    chickens.forEach(chicken => {
                        if (!chicken.alive) return;
                        const dx = chicken.x - this.x;
                        const dz = chicken.z - this.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 4) {
                            chicken.takeDamage(Math.round(this.damage * 0.5), this);
                            // Knockback
                            const knockback = 2;
                            chicken.x += (dx / dist) * knockback;
                            chicken.z += (dz / dist) * knockback;
                        }
                    });
                }
            }

            // Start charging ultimate
            startUltimate() {
                this.isChargingUltimate = true;
                this.ultimateChargeTime = 0;
                
                if (this.type === 'chicken') {
                    addLogEntry(`üêî Chicken #${this.id} is charging üí•EGG BOMB!`, 'chicken');
                    this.chargingEffect = createChargingEffect(this.x, 0.5, this.z, 0xff00ff, 1);
                } else {
                    addLogEntry(`üêÑ Cow #${this.id} is charging üí•MOO-CLEAR BLAST!`, 'cow');
                    this.chargingEffect = createMooClearChargeEffect(this);
                }
                skillEffects.push(this.chargingEffect);
            }

            // Release the ultimate attack
            releaseUltimate() {
                this.isChargingUltimate = false;
                this.ultimateCooldown = this.type === 'chicken' ? 10 : 12;
                
                // Remove charging effect
                if (this.chargingEffect) {
                    this.chargingEffect.life = 0;
                    this.chargingEffect = null;
                }
                
                if (this.type === 'chicken') {
                    // Egg Bomb - AOE explosion
                    addLogEntry(`üêî Chicken #${this.id} releases üí•EGG BOMB! BOOM!`, 'chicken');
                    skillEffects.push(createExplosionEffect(this.x, 1, this.z, 0xff00ff, 5, 30, 'chicken'));
                } else {
                    // MOO-CLEAR BLAST - Massive AOE
                    addLogEntry(`üêÑ Cow #${this.id} unleashes üí•MOO-CLEAR BLAST! BOOAAAH!`, 'cow');
                    skillEffects.push(createExplosionEffect(this.x, 1, this.z, 0xff4400, 10, 10, 'cow'));
                    
                    // Screen shake effect
                    const originalPos = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
                    let shakeTime = 0;
                    const shakeInterval = setInterval(() => {
                        shakeTime += 0.05;
                        if (shakeTime > 0.5) {
                            clearInterval(shakeInterval);
                            return;
                        }
                        camera.position.x = originalPos.x + (Math.random() - 0.5) * 2;
                        camera.position.y = originalPos.y + (Math.random() - 0.5) * 2;
                    }, 50);
                }
            }

            attack(target) {
                // Attack animation
                const originalY = this.mesh.position.y;
                this.mesh.position.y += 0.3;
                setTimeout(() => {
                    if (this.mesh) this.mesh.position.y = originalY;
                }, 100);

                // Apply damage with some variance
                const damageVariance = 0.8 + Math.random() * 0.4;
                const actualDamage = Math.round(this.damage * damageVariance);
                target.takeDamage(actualDamage, this);

                // Create hit particle
                createHitParticle(target.x, 1, target.z);
            }

            takeDamage(amount, attacker) {
                this.hp -= amount;
                updateHealthBar(this.healthBar, (this.hp / this.maxHp) * 100);

                if (this.hp <= 0) {
                    this.die(attacker);
                }
            }

            die(killer) {
                this.alive = false;

                // Death particles
                for (let i = 0; i < 10; i++) {
                    createDeathParticle(this.x, 1, this.z);
                }

                // Log the death
                addLogEntry(
                    `${this.type === 'chicken' ? 'üêî' : 'üêÑ'} ${this.type.charAt(0).toUpperCase() + this.type.slice(1)} #${this.id} was defeated!`,
                    this.type
                );

                scene.remove(this.mesh);
                this.mesh = null;
                updateStats();
            }
        }

        // Particles
        function createHitParticle(x, y, z) {
            const geometry = new THREE.SphereGeometry(0.1, 6, 6);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(x, y, z);
            scene.add(particle);
            
            particles.push({
                mesh: particle,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.2
                ),
                life: 1
            });
        }

        function createDeathParticle(x, y, z) {
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshBasicMaterial({ 
                color: Math.random() > 0.5 ? 0xffff00 : 0xff6600 
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(x, y, z);
            scene.add(particle);
            
            particles.push({
                mesh: particle,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3 + 0.1,
                    (Math.random() - 0.5) * 0.3
                ),
                life: 1.5
            });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.velocity);
                p.velocity.y -= 0.01; // gravity
                p.life -= 0.02;
                p.mesh.scale.multiplyScalar(0.98);
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function addLogEntry(text, type) {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = text;
            logEntries.insertBefore(entry, logEntries.firstChild);

            while (logEntries.children.length > 20) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        function initBattle() {
            // Clear existing
            chickens.forEach(c => { if (c.mesh) scene.remove(c.mesh); });
            cows.forEach(c => { if (c.mesh) scene.remove(c.mesh); });
            particles.forEach(p => scene.remove(p.mesh));
            skillEffects.forEach(e => scene.remove(e.mesh));
            
            chickens = [];
            cows = [];
            particles = [];
            skillEffects = [];
            battleActive = true;
            winnerEl.style.display = 'none';
            logEntries.innerHTML = '';

            // Create chickens on the left side
            for (let i = 0; i < 100; i++) {
                const x = -FIELD_SIZE + Math.random() * 30;
                const z = (Math.random() - 0.5) * FIELD_SIZE * 1.5;
                chickens.push(new Entity('chicken', x, z, i + 1));
            }

            // Create cows on the right side
            for (let i = 0; i < 3; i++) {
                const x = FIELD_SIZE - 20 + Math.random() * 15;
                const z = (i - 1) * 20;
                cows.push(new Entity('cow', x, z, i + 1));
            }

            addLogEntry('‚öîÔ∏è Battle has begun! 100 Chickens vs 3 Cows!', 'chicken');
            updateStats();
        }

        function updateStats() {
            const aliveChickens = chickens.filter(c => c.alive).length;
            const aliveCows = cows.filter(c => c.alive).length;

            chickenCountEl.textContent = aliveChickens;
            cowCountEl.textContent = aliveCows;

            if (aliveChickens === 0 && battleActive) {
                battleActive = false;
                winnerTextEl.innerHTML = 'üêÑ COWS WIN! üêÑ<br><span style="font-size: 18px;">The mighty cows have prevailed!</span>';
                winnerEl.style.display = 'block';
                addLogEntry('üèÜ COWS ARE VICTORIOUS!', 'cow');
                
                // Record result for ML
                mlBalance.recordResult('cow');
                
                // Handle auto-play
                handleAutoPlay();
            } else if (aliveCows === 0 && battleActive) {
                battleActive = false;
                winnerTextEl.innerHTML = 'üêî CHICKENS WIN! üêî<br><span style="font-size: 18px;">The chicken army triumphs!</span>';
                winnerEl.style.display = 'block';
                addLogEntry('üèÜ CHICKENS ARE VICTORIOUS!', 'chicken');
                
                // Record result for ML
                mlBalance.recordResult('chicken');
                
                // Handle auto-play
                handleAutoPlay();
            }
        }
        
        function handleAutoPlay() {
            if (autoBalanceRemaining > 0) {
                autoBalanceRemaining--;
                if (autoBalanceRemaining > 0) {
                    setTimeout(() => {
                        addLogEntry(`ü§ñ Auto-balance: ${autoBalanceRemaining} battles remaining`, 'chicken');
                        restartBattle();
                    }, 500);
                } else {
                    addLogEntry('ü§ñ Auto-balance complete!', 'chicken');
                }
            } else if (autoPlayEnabled) {
                setTimeout(() => {
                    restartBattle();
                }, 1500);
            }
        }

        function restartBattle() {
            initBattle();
        }

        // Camera controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraAngle = 0;
        let cameraHeight = 40;
        let cameraDistance = 70;

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            cameraAngle += deltaX * 0.01;
            cameraHeight = Math.max(10, Math.min(100, cameraHeight - deltaY * 0.2));
            
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('wheel', (e) => {
            cameraDistance = Math.max(30, Math.min(150, cameraDistance + e.deltaY * 0.05));
        });

        function updateCamera() {
            camera.position.x = Math.sin(cameraAngle) * cameraDistance;
            camera.position.z = Math.cos(cameraAngle) * cameraDistance;
            camera.position.y = cameraHeight;
            camera.lookAt(0, 0, 0);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (battleActive) {
                for (const chicken of chickens) {
                    chicken.update();
                }
                for (const cow of cows) {
                    cow.update();
                }
            }

            // Update skill effects
            for (let i = skillEffects.length - 1; i >= 0; i--) {
                const effect = skillEffects[i];
                const alive = effect.update(0.016);
                if (!alive) {
                    scene.remove(effect.mesh);
                    skillEffects.splice(i, 1);
                }
            }

            updateParticles();
            updateCamera();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        initBattle();
        animate();
    </script>
</body>
</html>
