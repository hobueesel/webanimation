<!DOCTYPE html>
<!-- saved from url=(0063)file:///C:/Users/krist/Documents/Code/webanimation/index36.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snowy Starry Night</title>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        #planet-core {
            position: fixed;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            z-index: 1;
            transform: translate(-50%, -50%);
        }
        #planet-core img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Animated Holiday Text */
        #holiday-text {
            position: fixed;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            font-family: 'Bangers', cursive;
            font-size: clamp(24px, 5vw, 72px);
            color: #ffffff;
            text-shadow: 
                1px 1px 0 rgba(0, 0, 0, 0.8),
                2px 2px 0 rgba(0, 0, 0, 0.6),
                3px 3px 4px rgba(0, 0, 0, 0.9),
                0 0 10px rgba(100, 150, 255, 0.5),
                0 0 20px rgba(100, 150, 255, 0.3),
                -1px -1px 0 rgba(255, 255, 255, 0.3);
            letter-spacing: 4px;
            white-space: nowrap;
            pointer-events: none;
            animation: textGlow 3s ease-in-out infinite;
        }
        
        #holiday-text span {
            display: inline-block;
            animation: squiggle 0.5s ease-in-out infinite;
        }
        
        @keyframes squiggle {
            0%, 100% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
            25% {
                transform: translateY(-6px) rotate(-3deg) scale(1.02);
            }
            50% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
            75% {
                transform: translateY(6px) rotate(3deg) scale(0.98);
            }
        }
        
        @keyframes textGlow {
            0%, 100% { 
                opacity: 0.9;
                text-shadow: 
                    1px 1px 0 rgba(0, 0, 0, 0.8),
                    2px 2px 0 rgba(0, 0, 0, 0.6),
                    3px 3px 4px rgba(0, 0, 0, 0.9),
                    0 0 10px rgba(100, 150, 255, 0.5),
                    0 0 20px rgba(100, 150, 255, 0.3),
                    -1px -1px 0 rgba(255, 255, 255, 0.3);
            }
            50% { 
                opacity: 1;
                text-shadow: 
                    1px 1px 0 rgba(0, 0, 0, 0.8),
                    2px 2px 0 rgba(0, 0, 0, 0.6),
                    3px 3px 4px rgba(0, 0, 0, 0.9),
                    0 0 15px rgba(150, 200, 255, 0.7),
                    0 0 30px rgba(100, 150, 255, 0.5),
                    -1px -1px 0 rgba(255, 255, 255, 0.5);
            }
        }
    </style>
</head>
<body>
    <!-- Animated Holiday Text -->
    <div id="holiday-text"></div>
    
    <canvas id="glCanvas" width="1536" height="729"></canvas>
    
    <!-- Planet Core GIF -->
    <div id="planet-core">
        <img src="cool-tuvi.gif" alt="Planet Core">
    </div>

    <!-- Vertex Shader for Snow -->
    <script id="snow-vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute float aSize;
        attribute float aSpeed;
        attribute float aOffset;
        
        uniform float uTime;
        uniform vec2 uResolution;
        uniform float uScale;
        uniform float uDepth;
        uniform float uSpeedMultiplier;
        uniform float uPlanetRadius;
        
        varying float vAlpha;
        
        void main() {
            // aPosition.x is the angle (0-1 maps to 0-2PI)
            // aPosition.y is used for radial distance variation
            float angle = aPosition.x * 6.28318530718; // 2*PI
            
            // Animate snow falling radially inward
            float maxRadius = 1.5; // Start from beyond screen edge
            float fallProgress = mod(uTime * aSpeed * uSpeedMultiplier * 0.3 + aOffset, 1.0);
            float radius = maxRadius * (1.0 - fallProgress) + uPlanetRadius * fallProgress;
            
            // Add some angular drift
            float drift = sin(uTime * 0.3 + aOffset * 10.0) * 0.1;
            float finalAngle = angle + drift;
            
            // Convert polar to cartesian (centered at 0,0)
            float x = cos(finalAngle) * radius;
            float y = sin(finalAngle) * radius;
            
            // Fade in at edge, fade out near planet
            float fadeIn = smoothstep(0.0, 0.1, fallProgress);
            float fadeOut = smoothstep(1.0, 0.85, fallProgress);
            vAlpha = fadeIn * fadeOut * uDepth;
            
            // Adjust for aspect ratio
            float aspect = uResolution.x / uResolution.y;
            gl_Position = vec4(x / aspect, y, aPosition.z, 1.0);
            gl_PointSize = aSize * (uResolution.y / 800.0) * uScale;
        }
    </script>

    <!-- Fragment Shader for Snow -->
    <script id="snow-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying float vAlpha;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if(dist > 0.5) {
                discard;
            }
            
            float alpha = (1.0 - dist * 2.0) * vAlpha;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
    </script>

    <!-- Vertex Shader for Accumulated Snow -->
    <script id="accumulated-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition; // x = angle, y = radius
        attribute float aSize;
        
        uniform vec2 uResolution;
        uniform float uScale;
        
        void main() {
            // aPosition.x is angle in radians, aPosition.y is radius
            float x = cos(aPosition.x) * aPosition.y;
            float y = sin(aPosition.x) * aPosition.y;
            
            float aspect = uResolution.x / uResolution.y;
            gl_Position = vec4(x / aspect, y, 0.0, 1.0);
            gl_PointSize = aSize * (uResolution.y / 800.0) * uScale;
        }
    </script>

    <!-- Fragment Shader for Accumulated Snow -->
    <script id="accumulated-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if(dist > 0.5) {
                discard;
            }
            
            float alpha = 1.0 - dist * 2.0;
            gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
    </script>

    <!-- Vertex Shader for Lightning -->
    <script id="lightning-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        attribute float aAlpha;
        
        uniform vec2 uResolution;
        
        varying float vAlpha;
        
        void main() {
            float aspect = uResolution.x / uResolution.y;
            gl_Position = vec4(aPosition.x / aspect, aPosition.y, 0.0, 1.0);
            vAlpha = aAlpha;
        }
    </script>

    <!-- Fragment Shader for Lightning -->
    <script id="lightning-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying float vAlpha;
        
        void main() {
            // Electric blue-white color
            vec3 coreColor = vec3(1.0, 1.0, 1.0);
            vec3 glowColor = vec3(0.3, 0.6, 1.0);
            vec3 color = mix(glowColor, coreColor, vAlpha);
            gl_FragColor = vec4(color, vAlpha);
        }
    </script>

    <!-- Vertex Shader for Sprites (firework particles) -->
    <script id="sprite-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        attribute float aSize;
        attribute float aAlpha;
        attribute vec3 aColor;
        
        uniform vec2 uResolution;
        
        varying float vAlpha;
        varying vec3 vColor;
        
        void main() {
            float aspect = uResolution.x / uResolution.y;
            gl_Position = vec4(aPosition.x / aspect, aPosition.y, 0.0, 1.0);
            gl_PointSize = aSize * (uResolution.y / 800.0);
            vAlpha = aAlpha;
            vColor = aColor;
        }
    </script>

    <!-- Fragment Shader for Sprites (firework particles) -->
    <script id="sprite-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying float vAlpha;
        varying vec3 vColor;
        
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if(dist > 0.5) {
                discard;
            }
            
            // Soft glowing particle with color
            float softEdge = 1.0 - smoothstep(0.0, 0.5, dist);
            float glow = exp(-dist * 4.0);
            
            // Bright white core fading to color
            vec3 coreColor = vec3(1.0, 1.0, 1.0);
            vec3 color = mix(vColor, coreColor, glow * 0.7);
            
            float alpha = softEdge * vAlpha * (0.6 + glow * 0.4);
            gl_FragColor = vec4(color, alpha);
        }
    </script>

    <!-- Vertex Shader for Background -->
    <script id="bg-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        varying vec2 vUv;
        
        void main() {
            vUv = aPosition * 0.5 + 0.5;
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader for Background -->
    <script id="bg-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform float uTime;
        uniform vec2 uResolution;
        uniform float uPlanetRadius;
        uniform float uGlobeRadius;
        
        varying vec2 vUv;
        
        // Simple noise function
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }
        
        void main() {
            vec2 uv = vUv;
            
            // Convert to centered coordinates with aspect ratio correction
            vec2 centered = (uv - 0.5) * 2.0;
            centered.x *= uResolution.x / uResolution.y;
            
            // Distance from center
            float dist = length(centered);
            
            // Deep space background
            vec3 spaceColor = vec3(0.0, 0.0, 0.05);
            
            // Radial glow around planet
            vec3 glowColor = vec3(0.2, 0.5, 1.0); // Electric blue glow
            vec3 midGlow = vec3(0.05, 0.1, 0.3); // Deep blue
            
            // Create radial gradient from planet outward
            float glowStart = uPlanetRadius;
            float glowEnd = uPlanetRadius + 0.4;
            float glowFactor = 1.0 - smoothstep(glowStart, glowEnd, dist);
            
            // Atmosphere layers
            float innerGlow = 1.0 - smoothstep(glowStart, glowStart + 0.15, dist);
            float outerGlow = 1.0 - smoothstep(glowStart + 0.1, glowEnd, dist);
            
            vec3 color = spaceColor;
            color = mix(color, midGlow, outerGlow * 0.5);
            color = mix(color, glowColor, innerGlow * 0.7);
            
            // Outer globe sphere (plasma ball glass)
            float globeEdge = abs(dist - uGlobeRadius);
            float globeRing = smoothstep(0.02, 0.0, globeEdge);
            float globeGlow = smoothstep(0.08, 0.0, globeEdge);
            vec3 globeColor = vec3(0.15, 0.3, 0.5);
            color = mix(color, globeColor, globeGlow * 0.3);
            color = mix(color, vec3(0.3, 0.5, 0.8), globeRing * 0.4);
            
            // Planet itself (transparent to show GIF underneath)
            if(dist < uPlanetRadius) {
                // Just show a subtle edge glow, keep center transparent
                float edgeGlow = smoothstep(uPlanetRadius - 0.02, uPlanetRadius, dist);
                vec3 edgeColor = vec3(0.1, 0.2, 0.4);
                color = mix(vec3(0.0), edgeColor, edgeGlow);
                // Make the center more transparent
                float alpha = smoothstep(uPlanetRadius - 0.03, uPlanetRadius, dist);
                gl_FragColor = vec4(color, alpha);
                return;
            }
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false });

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            updatePlanetCorePosition();
        }
        
        // Position the planet core GIF to match the WebGL planet
        const planetCoreElement = document.getElementById('planet-core');
        function updatePlanetCorePosition() {
            const PLANET_RADIUS = 0.15; // Same as in the shader
            
            // Use the actual canvas dimensions for consistent sizing
            const canvasRect = canvas.getBoundingClientRect();
            const displayHeight = canvasRect.height;
            
            // Planet radius in pixels (account for aspect ratio) - make it smaller
            const radiusPixels = PLANET_RADIUS * displayHeight * 0.4;
            
            // Only set the size - CSS handles the centering with position: fixed and transform
            const size = radiusPixels * 2;
            planetCoreElement.style.width = size + 'px';
            planetCoreElement.style.height = size + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Get shader source from script tag
        function getShaderSource(id) {
            return document.getElementById(id).textContent;
        }

        // Create background program
        const bgVertexShader = compileShader(gl, getShaderSource('bg-vertex-shader'), gl.VERTEX_SHADER);
        const bgFragmentShader = compileShader(gl, getShaderSource('bg-fragment-shader'), gl.FRAGMENT_SHADER);
        const bgProgram = createProgram(gl, bgVertexShader, bgFragmentShader);

        // Background quad
        const bgVertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const bgBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, bgVertices, gl.STATIC_DRAW);

        const bgPositionLocation = gl.getAttribLocation(bgProgram, 'aPosition');
        const bgTimeLocation = gl.getUniformLocation(bgProgram, 'uTime');
        const bgResolutionLocation = gl.getUniformLocation(bgProgram, 'uResolution');
        const bgPlanetRadiusLocation = gl.getUniformLocation(bgProgram, 'uPlanetRadius');
        const bgGlobeRadiusLocation = gl.getUniformLocation(bgProgram, 'uGlobeRadius');

        // Create snow program
        const snowVertexShader = compileShader(gl, getShaderSource('snow-vertex-shader'), gl.VERTEX_SHADER);
        const snowFragmentShader = compileShader(gl, getShaderSource('snow-fragment-shader'), gl.FRAGMENT_SHADER);
        const snowProgram = createProgram(gl, snowVertexShader, snowFragmentShader);

        // Snow particles - different amounts per layer
        const layer1Count = 1000;
        const layer2Count = 10000;
        const layer3Count = 30000;
        const numSnowflakes = layer1Count + layer2Count + layer3Count;
        const snowPositions = [];
        const snowSizes = [];
        const snowSpeeds = [];
        const snowOffsets = [];

        for (let i = 0; i < numSnowflakes; i++) {
            // Position - now angle-based for radial distribution
            snowPositions.push(Math.random()); // angle (0-1 maps to 0-2PI)
            snowPositions.push(Math.random()); // radial variation
            snowPositions.push(Math.random() * 0.5); // z (for depth)
            
            // Size (larger in front)
            const depth = snowPositions[i * 3 + 2];
            snowSizes.push(2.0 + (1.0 - depth) * 4.0);
            
            // Speed (faster in front)
            snowSpeeds.push(0.1 + (1.0 - depth) * 0.3);
            
            // Random offset for staggered animation
            snowOffsets.push(Math.random());
        }

        // Create buffers for snow
        const snowPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowPositions), gl.STATIC_DRAW);

        const snowSizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowSizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowSizes), gl.STATIC_DRAW);

        const snowSpeedBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowSpeedBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowSpeeds), gl.STATIC_DRAW);

        const snowOffsetBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowOffsetBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowOffsets), gl.STATIC_DRAW);

        // Get attribute locations for snow
        const snowPositionLocation = gl.getAttribLocation(snowProgram, 'aPosition');
        const snowSizeLocation = gl.getAttribLocation(snowProgram, 'aSize');
        const snowSpeedLocation = gl.getAttribLocation(snowProgram, 'aSpeed');
        const snowOffsetLocation = gl.getAttribLocation(snowProgram, 'aOffset');
        const snowTimeLocation = gl.getUniformLocation(snowProgram, 'uTime');
        const snowResolutionLocation = gl.getUniformLocation(snowProgram, 'uResolution');
        const snowScaleLocation = gl.getUniformLocation(snowProgram, 'uScale');
        const snowDepthLocation = gl.getUniformLocation(snowProgram, 'uDepth');
        const snowSpeedMultiplierLocation = gl.getUniformLocation(snowProgram, 'uSpeedMultiplier');
        const snowPlanetRadiusLocation = gl.getUniformLocation(snowProgram, 'uPlanetRadius');
        
        // Planet radius
        const PLANET_RADIUS = 0.15;

        // Create accumulated snow program
        const accVertexShader = compileShader(gl, getShaderSource('accumulated-vertex-shader'), gl.VERTEX_SHADER);
        const accFragmentShader = compileShader(gl, getShaderSource('accumulated-fragment-shader'), gl.FRAGMENT_SHADER);
        const accProgram = createProgram(gl, accVertexShader, accFragmentShader);

        const accPositionLocation = gl.getAttribLocation(accProgram, 'aPosition');
        const accSizeLocation = gl.getAttribLocation(accProgram, 'aSize');
        const accResolutionLocation = gl.getUniformLocation(accProgram, 'uResolution');
        const accScaleLocation = gl.getUniformLocation(accProgram, 'uScale');

        // Create lightning program
        const lightningVertexShader = compileShader(gl, getShaderSource('lightning-vertex-shader'), gl.VERTEX_SHADER);
        const lightningFragmentShader = compileShader(gl, getShaderSource('lightning-fragment-shader'), gl.FRAGMENT_SHADER);
        const lightningProgram = createProgram(gl, lightningVertexShader, lightningFragmentShader);

        const lightningPositionLocation = gl.getAttribLocation(lightningProgram, 'aPosition');
        const lightningAlphaLocation = gl.getAttribLocation(lightningProgram, 'aAlpha');
        const lightningResolutionLocation = gl.getUniformLocation(lightningProgram, 'uResolution');

        // Lightning system
        const activeLightningBolts = [];
        const LIGHTNING_THRESHOLD = 0.005; // Height threshold to trigger lightning
        const LIGHTNING_DURATION = 0.6; // How long lightning lasts in seconds (increased for visibility)
        const GLOBE_RADIUS = 1.5; // Outer sphere - matches snow maxRadius so lightning starts where snow appears
        let lastLightningCheck = 0;

        // Create sprite program for fireworks
        const spriteVertexShader = compileShader(gl, getShaderSource('sprite-vertex-shader'), gl.VERTEX_SHADER);
        const spriteFragmentShader = compileShader(gl, getShaderSource('sprite-fragment-shader'), gl.FRAGMENT_SHADER);
        const spriteProgram = createProgram(gl, spriteVertexShader, spriteFragmentShader);

        const spritePositionLocation = gl.getAttribLocation(spriteProgram, 'aPosition');
        const spriteSizeLocation = gl.getAttribLocation(spriteProgram, 'aSize');
        const spriteAlphaLocation = gl.getAttribLocation(spriteProgram, 'aAlpha');
        const spriteColorLocation = gl.getAttribLocation(spriteProgram, 'aColor');
        const spriteResolutionLocation = gl.getUniformLocation(spriteProgram, 'uResolution');

        // Fireworks system
        const activeFireworks = [];
        const FIREWORK_STAGE_1_DURATION = 0.5; // Initial projectile flight
        const FIREWORK_STAGE_2_DURATION = 0.7; // First explosion particles
        const FIREWORK_STAGE_3_DURATION = 1.0; // Final tiny sparkles
        const SCREEN_EDGE_RADIUS = 2.5; // Roughly the edges of the screen

        // Firework particle class
        class FireworkParticle {
            constructor(x, y, vx, vy, stage, color, size, lifetime) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.stage = stage; // 1 = initial projectile, 2 = first explosion, 3 = final sparkles
                this.color = color; // {r, g, b}
                this.size = size;
                this.lifetime = lifetime;
                this.age = 0;
                this.hasExploded = false;
                this.gravity = stage === 1 ? 0 : (stage === 2 ? 0.08 : 0.2); // Reduced gravity for more spread
                this.drag = stage === 1 ? 0.99 : (stage === 2 ? 0.97 : 0.95); // Less drag for farther travel
            }

            update(dt) {
                this.age += dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy -= this.gravity * dt; // Apply gravity
                this.vx *= this.drag;
                this.vy *= this.drag;
                
                // Track if trail should be emitted (for stage 1 only)
                this.shouldEmitTrail = this.stage === 1 && Math.random() < 0.4;
                
                return this.age < this.lifetime;
            }

            getAlpha() {
                const progress = this.age / this.lifetime;
                // Fade out in the last 30% of lifetime
                if (progress > 0.7) {
                    return 1.0 - (progress - 0.7) / 0.3;
                }
                return 1.0;
            }

            shouldExplode() {
                // Stage 1 explodes at ~60% of lifetime, stage 2 at ~70%
                const explodeTime = this.stage === 1 ? 0.6 : 0.7;
                return !this.hasExploded && this.age >= this.lifetime * explodeTime;
            }
        }

        // Create a firework from a lightning hit point
        function createFirework(hitX, hitY, hitAngle) {
            const firework = {
                particles: [],
                startTime: (Date.now() - startTime) / 1000.0
            };

            // Create 1-2 initial projectiles shooting outward
            const numProjectiles = 1 + Math.floor(Math.random() * 2);
            
            for (let i = 0; i < numProjectiles; i++) {
                // Direction perpendicular to globe (outward from center)
                const spreadAngle = hitAngle + (Math.random() - 0.5) * 0.4;
                const speed = 2.5 + Math.random() * 1.5; // Very fast initial velocity to reach screen edges
                
                const vx = Math.cos(spreadAngle) * speed;
                const vy = Math.sin(spreadAngle) * speed;
                
                // Random bright color for this firework
                const hue = Math.random() * 360;
                const color = hslToRgb(hue, 1.0, 0.6);
                
                const particle = new FireworkParticle(
                    hitX, hitY,
                    vx, vy,
                    1, // Stage 1
                    color,
                    30, // Large initial projectile
                    FIREWORK_STAGE_1_DURATION
                );
                
                firework.particles.push(particle);
            }

            activeFireworks.push(firework);
        }

        // HSL to RGB conversion for colorful fireworks
        function hslToRgb(h, s, l) {
            h = h / 360;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r, g, b };
        }

        // Create explosion from a particle
        function explodeParticle(particle) {
            const newParticles = [];
            const nextStage = particle.stage + 1;
            
            if (nextStage > 3) return newParticles;

            // Number of particles in explosion
            const numParticles = nextStage === 2 ? (10 + Math.floor(Math.random() * 8)) : (6 + Math.floor(Math.random() * 5));
            
            // Lifetime for new particles
            const lifetime = nextStage === 2 ? FIREWORK_STAGE_2_DURATION : FIREWORK_STAGE_3_DURATION;
            
            // Size reduction
            const newSize = nextStage === 2 ? (12 + Math.random() * 8) : (4 + Math.random() * 4);
            
            // Speed of explosion - faster to spread further
            const explosionSpeed = nextStage === 2 ? (1.5 + Math.random() * 1.0) : (0.6 + Math.random() * 0.5);

            // Slight color variation
            const baseHue = rgbToHue(particle.color);

            for (let i = 0; i < numParticles; i++) {
                // Random direction in a sphere
                const angle = (i / numParticles) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
                const speedVariation = 0.7 + Math.random() * 0.6;
                
                const vx = Math.cos(angle) * explosionSpeed * speedVariation + particle.vx * 0.4;
                const vy = Math.sin(angle) * explosionSpeed * speedVariation + particle.vy * 0.4;

                // Vary the hue slightly
                const hue = (baseHue + (Math.random() - 0.5) * 30 + 360) % 360;
                const color = hslToRgb(hue, 0.9, 0.5 + Math.random() * 0.2);

                const newParticle = new FireworkParticle(
                    particle.x, particle.y,
                    vx, vy,
                    nextStage,
                    color,
                    newSize,
                    lifetime
                );

                newParticles.push(newParticle);
            }

            return newParticles;
        }

        // RGB to Hue for color variation
        function rgbToHue(color) {
            const r = color.r, g = color.g, b = color.b;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h;
            if (max === min) {
                h = 0;
            } else if (max === r) {
                h = (60 * ((g - b) / (max - min)) + 360) % 360;
            } else if (max === g) {
                h = 60 * ((b - r) / (max - min)) + 120;
            } else {
                h = 60 * ((r - g) / (max - min)) + 240;
            }
            return h;
        }

        // Update fireworks system
        function updateFireworks(currentTime, dt) {
            for (let f = activeFireworks.length - 1; f >= 0; f--) {
                const firework = activeFireworks[f];
                const newParticles = [];

                for (let p = firework.particles.length - 1; p >= 0; p--) {
                    const particle = firework.particles[p];
                    
                    // Check if should explode before updating
                    if (particle.shouldExplode() && particle.stage < 3) {
                        particle.hasExploded = true;
                        const explosionParticles = explodeParticle(particle);
                        newParticles.push(...explosionParticles);
                    }

                    // Update particle
                    if (!particle.update(dt)) {
                        // Particle expired
                        firework.particles.splice(p, 1);
                    } else {
                        // Create trail particles for stage 1 projectiles
                        if (particle.shouldEmitTrail) {
                            const trailParticle = new FireworkParticle(
                                particle.x + (Math.random() - 0.5) * 0.02,
                                particle.y + (Math.random() - 0.5) * 0.02,
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.1 - 0.1, // Slight downward
                                3, // Stage 3 (sparkle)
                                { r: 1.0, g: 0.9, b: 0.6 }, // Golden trail
                                5 + Math.random() * 4,
                                0.3 + Math.random() * 0.2
                            );
                            newParticles.push(trailParticle);
                        }
                    }
                }

                // Add new particles from explosions and trails
                firework.particles.push(...newParticles);

                // Remove firework if no particles left
                if (firework.particles.length === 0) {
                    activeFireworks.splice(f, 1);
                }
            }
        }

        // Render fireworks
        function renderFireworks() {
            if (activeFireworks.length === 0) return;

            gl.useProgram(spriteProgram);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending for glowing effect

            gl.uniform2f(spriteResolutionLocation, canvas.width, canvas.height);

            // Collect all particles
            const positions = [];
            const sizes = [];
            const alphas = [];
            const colors = [];

            activeFireworks.forEach(firework => {
                firework.particles.forEach(particle => {
                    positions.push(particle.x, particle.y);
                    sizes.push(particle.size);
                    alphas.push(particle.getAlpha());
                    colors.push(particle.color.r, particle.color.g, particle.color.b);
                });
            });

            if (positions.length === 0) return;

            // Create buffers
            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(spritePositionLocation);
            gl.vertexAttribPointer(spritePositionLocation, 2, gl.FLOAT, false, 0, 0);

            const sizeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(spriteSizeLocation);
            gl.vertexAttribPointer(spriteSizeLocation, 1, gl.FLOAT, false, 0, 0);

            const alphaBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(alphas), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(spriteAlphaLocation);
            gl.vertexAttribPointer(spriteAlphaLocation, 1, gl.FLOAT, false, 0, 0);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(spriteColorLocation);
            gl.vertexAttribPointer(spriteColorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, positions.length / 2);

            gl.disableVertexAttribArray(spritePositionLocation);
            gl.disableVertexAttribArray(spriteSizeLocation);
            gl.disableVertexAttribArray(spriteAlphaLocation);
            gl.disableVertexAttribArray(spriteColorLocation);

            gl.deleteBuffer(posBuffer);
            gl.deleteBuffer(sizeBuffer);
            gl.deleteBuffer(alphaBuffer);
            gl.deleteBuffer(colorBuffer);

            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }

        // Render sprites function (for backward compatibility)
        function renderSprites(currentTime) {
            // This is now handled by renderFireworks
        }

        // Snow accumulation system - now radial around planet
        const HEIGHTMAP_RESOLUTION = 360; // Number of angle buckets (degrees)
        
        // Each layer has its own heightmap (radial) and accumulated particles
        const layers = [
            { 
                name: 'layer3',
                startIdx: 0,
                count: layer3Count,
                speedMult: 0.3,
                scale: 0.4,
                growthRate: 0.3, // Slower growth for far layer
                heightmap: new Float32Array(HEIGHTMAP_RESOLUTION).fill(0), // Radial height at each angle
                accumulated: { positions: [], sizes: [], count: 0, buffer: null, sizeBuffer: null }
            },
            { 
                name: 'layer2',
                startIdx: layer3Count,
                count: layer2Count,
                speedMult: 0.6,
                scale: 0.7,
                growthRate: 0.6, // Medium growth
                heightmap: new Float32Array(HEIGHTMAP_RESOLUTION).fill(0),
                accumulated: { positions: [], sizes: [], count: 0, buffer: null, sizeBuffer: null }
            },
            { 
                name: 'layer1',
                startIdx: layer3Count + layer2Count,
                count: layer1Count,
                speedMult: 1.0,
                scale: 1.0,
                growthRate: 1.0, // Faster growth for near layer
                heightmap: new Float32Array(HEIGHTMAP_RESOLUTION).fill(0),
                accumulated: { positions: [], sizes: [], count: 0, buffer: null, sizeBuffer: null }
            }
        ];

        // Track which particles have already accumulated
        const accumulatedParticles = new Set();

        // Animation loop
        let startTime = Date.now();

        function getHeightmapIndex(angle) {
            // Normalize angle to 0-2PI, then map to index
            let normalizedAngle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            return Math.floor((normalizedAngle / (Math.PI * 2)) * HEIGHTMAP_RESOLUTION) % HEIGHTMAP_RESOLUTION;
        }

        function getHeightAtAngle(layer, angle) {
            const idx = getHeightmapIndex(angle);
            return layer.heightmap[idx];
        }

        function addSnowToHeightmap(layer, angle, amount) {
            const idx = getHeightmapIndex(angle);
            layer.heightmap[idx] += amount * layer.growthRate;
        }

        // Redistribute snow around the planet when too much accumulates
        function redistributeSnow(layer) {
            const MAX_HEIGHT_DIFFERENCE = 0.003; // Maximum allowed height difference between adjacent cells
            const SPREAD_RATE = 0.15; // How much snow spreads to neighbors
            
            const newHeightmap = new Float32Array(layer.heightmap);
            
            for (let i = 0; i < HEIGHTMAP_RESOLUTION; i++) {
                const currentHeight = layer.heightmap[i];
                // Wrap around for circular planet
                const leftIdx = (i - 1 + HEIGHTMAP_RESOLUTION) % HEIGHTMAP_RESOLUTION;
                const rightIdx = (i + 1) % HEIGHTMAP_RESOLUTION;
                const leftHeight = layer.heightmap[leftIdx];
                const rightHeight = layer.heightmap[rightIdx];
                
                // Check if current cell is significantly higher than neighbors
                const leftDiff = currentHeight - leftHeight;
                const rightDiff = currentHeight - rightHeight;
                
                if (leftDiff > MAX_HEIGHT_DIFFERENCE) {
                    // Spread to left
                    const spreadAmount = (leftDiff - MAX_HEIGHT_DIFFERENCE) * SPREAD_RATE;
                    newHeightmap[i] -= spreadAmount;
                    newHeightmap[leftIdx] += spreadAmount;
                }
                
                if (rightDiff > MAX_HEIGHT_DIFFERENCE) {
                    // Spread to right
                    const spreadAmount = (rightDiff - MAX_HEIGHT_DIFFERENCE) * SPREAD_RATE;
                    newHeightmap[i] -= spreadAmount;
                    newHeightmap[rightIdx] += spreadAmount;
                }
            }
            
            layer.heightmap.set(newHeightmap);
        }

        // Catmull-Rom spline interpolation for smooth curves
        function catmullRomPoint(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            
            return {
                x: 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
                y: 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)
            };
        }

        // Generate smooth curved lightning bolt path - starts from planet, spreads outward to globe
        function generateLightningBolt(startAngle, layer, currentTime) {
            const segments = [];
            const hitPoints = []; // Track where lightning hits the outer globe
            
            // Get all accumulated snow positions for this layer to use as attraction points
            const snowParticles = [];
            for (let i = 0; i < layer.accumulated.positions.length; i += 2) {
                const angle = layer.accumulated.positions[i];
                const radius = layer.accumulated.positions[i + 1];
                snowParticles.push({ angle, radius, used: false });
            }
            
            // Sort by radius (inner to outer) for finding targets
            snowParticles.sort((a, b) => a.radius - b.radius);
            
            // OUTER SPHERE RADIUS - the glass ball edge where lightning ends
            const outerRadius = 1.5;
            const innerRadius = PLANET_RADIUS;
            
            // Start with very few main branches from the planet, they will split outward
            const numStartBranches = 2 + Math.floor(Math.random() * 2); // 2-3 main starting branches
            const branchPaths = []; // Store control points for each branch
            let branchIdCounter = 0;
            
            // Helper function to generate a branch path going OUTWARD
            function generateBranchPath(branchStartAngle, startRadius, endRadius, parentId, depth, inheritedThickness) {
                const controlPoints = [];
                let currentAngle = branchStartAngle;
                let currentRadius = startRadius;
                const branchId = branchIdCounter++;
                
                // Number of control points - main branches are longer
                const numPoints = depth === 0 ? (18 + Math.floor(Math.random() * 8)) : 
                                  depth === 1 ? (12 + Math.floor(Math.random() * 6)) :
                                  depth === 2 ? (8 + Math.floor(Math.random() * 4)) :
                                  (5 + Math.floor(Math.random() * 3));
                const radiusStep = (endRadius - startRadius) / numPoints;
                
                // Random phase offset for unique wave patterns
                const phaseOffset = Math.random() * Math.PI * 2;
                
                // Track split points for creating sub-branches
                const splitPoints = [];
                
                for (let p = 0; p <= numPoints; p++) {
                    const progressOutward = p / numPoints;
                    const absoluteProgress = (currentRadius - innerRadius) / (outerRadius - innerRadius);
                    
                    // Smooth curved deviation - MORE deviation as we go outward (spreading)
                    const spreadFactor = 0.5 + absoluteProgress * 1.5; // Increases outward
                    const wave1 = Math.sin(progressOutward * Math.PI * 2.5 + phaseOffset) * 0.12 * spreadFactor;
                    const wave2 = Math.sin(progressOutward * Math.PI * 5 + phaseOffset * 1.7) * 0.06 * spreadFactor;
                    const wave3 = Math.sin(progressOutward * Math.PI * 8 + phaseOffset * 2.3) * 0.03 * spreadFactor;
                    const curveDeviation = wave1 + wave2 + wave3;
                    
                    // Add randomness that increases outward
                    const randomDeviation = (Math.random() - 0.5) * 0.1 * (0.5 + absoluteProgress);
                    
                    currentAngle = branchStartAngle + curveDeviation + randomDeviation;
                    currentRadius = startRadius + radiusStep * p;
                    
                    // Look for snow particles to attract to
                    for (const particle of snowParticles) {
                        if (particle.used) continue;
                        if (Math.abs(particle.radius - currentRadius) < 0.12) {
                            let angleDiff = Math.abs(particle.angle - currentAngle);
                            angleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                            
                            if (angleDiff < 0.2) {
                                currentAngle = currentAngle * 0.6 + particle.angle * 0.4;
                                particle.used = true;
                                break;
                            }
                        }
                    }
                    
                    // Convert to cartesian
                    const x = Math.cos(currentAngle) * Math.min(outerRadius, currentRadius);
                    const y = Math.sin(currentAngle) * Math.min(outerRadius, currentRadius);
                    
                    controlPoints.push({ 
                        x, y, 
                        radius: currentRadius,
                        thickness: inheritedThickness,
                        angle: currentAngle
                    });
                    
                    // Decide if we should split here - limited splitting for cleaner look
                    // Reduced split chance for fewer branches reaching outer edge
                    if (depth < 3 && p > 2 && p < numPoints - 2) {
                        // Much lower split chances - roughly 10x fewer total branches
                        const baseSplitChance = depth === 0 ? 0.08 : (depth === 1 ? 0.05 : 0.03);
                        const outerBonus = absoluteProgress * 0.05; // Slight increase near outer edge
                        const splitChance = baseSplitChance + outerBonus;
                        
                        if (Math.random() < splitChance && currentRadius < endRadius - 0.15) {
                            splitPoints.push({
                                angle: currentAngle,
                                radius: currentRadius,
                                depth: depth + 1
                            });
                        }
                    }
                }
                
                branchPaths.push({
                    points: controlPoints,
                    id: branchId,
                    parentId: parentId,
                    active: true,
                    thickness: inheritedThickness,
                    depth: depth
                });
                
                // Track hit point at the outer globe (last control point)
                const lastPoint = controlPoints[controlPoints.length - 1];
                if (lastPoint && lastPoint.radius >= outerRadius - 0.1) {
                    hitPoints.push({
                        x: lastPoint.x,
                        y: lastPoint.y,
                        angle: lastPoint.angle
                    });
                }
                
                // Generate sub-branches from split points - they spread outward
                splitPoints.forEach(split => {
                    // Split off at an angle from the parent - wider angles for outer splits
                    const spreadAngle = 0.15 + (split.radius - innerRadius) / (outerRadius - innerRadius) * 0.35;
                    const splitAngleOffset = (Math.random() > 0.5 ? 1 : -1) * (spreadAngle + Math.random() * 0.2);
                    
                    generateBranchPath(
                        split.angle + splitAngleOffset, 
                        split.radius, 
                        outerRadius,
                        branchId, 
                        split.depth,
                        1
                    );
                });
            }
            
            // Generate main branches starting from the planet going outward
            for (let i = 0; i < numStartBranches; i++) {
                const angleSpread = (Math.random() - 0.5) * 0.4; // Start close together at planet
                const branchStartAngle = startAngle + angleSpread;
                const startRadius = innerRadius + 0.01;
                
                // Start with thick main branches (thickness 4) - they're fat at the root!
                generateBranchPath(branchStartAngle, startRadius, outerRadius, -1, 0, 4);
            }
            
            // No merging needed for outward-spreading lightning
            
            // Generate smooth curved segments using Catmull-Rom interpolation
            branchPaths.forEach(branch => {
                if (!branch.active) return;
                
                const points = branch.points;
                if (points.length < 4) return;
                
                // Interpolate between control points for smooth curves
                const segmentsPerSpan = 5; // More segments = smoother curves
                
                for (let i = 0; i < points.length - 1; i++) {
                    // Get 4 control points for Catmull-Rom (with clamping at edges)
                    const p0 = points[Math.max(0, i - 1)];
                    const p1 = points[i];
                    const p2 = points[Math.min(points.length - 1, i + 1)];
                    const p3 = points[Math.min(points.length - 1, i + 2)];
                    
                    // Interpolate thickness based on radius (thicker near center)
                    const progressToCenter = 1.0 - (p1.radius - innerRadius) / (outerRadius - innerRadius);
                    const segThickness = branch.thickness;
                    
                    // Generate smooth curve segments
                    for (let s = 0; s < segmentsPerSpan; s++) {
                        const t1 = s / segmentsPerSpan;
                        const t2 = (s + 1) / segmentsPerSpan;
                        
                        const point1 = catmullRomPoint(p0, p1, p2, p3, t1);
                        const point2 = catmullRomPoint(p0, p1, p2, p3, t2);
                        
                        // Interpolate radius for this segment
                        const segRadius = p1.radius * (1 - t1) + p2.radius * t1;
                        
                        // Ensure no segment crosses the planet core
                        const dist1 = Math.sqrt(point1.x * point1.x + point1.y * point1.y);
                        const dist2 = Math.sqrt(point2.x * point2.x + point2.y * point2.y);
                        
                        // Skip segments that would be inside the planet
                        if (dist1 < innerRadius || dist2 < innerRadius) {
                            continue;
                        }
                        
                        // Clamp points to planet surface if they're too close
                        let x1 = point1.x, y1 = point1.y;
                        let x2 = point2.x, y2 = point2.y;
                        
                        if (dist1 < innerRadius + 0.01) {
                            const scale = (innerRadius + 0.01) / dist1;
                            x1 *= scale;
                            y1 *= scale;
                        }
                        if (dist2 < innerRadius + 0.01) {
                            const scale = (innerRadius + 0.01) / dist2;
                            x2 *= scale;
                            y2 *= scale;
                        }
                        
                        segments.push({
                            x1: x1,
                            y1: y1,
                            x2: x2,
                            y2: y2,
                            thickness: segThickness,
                            radius: segRadius
                        });
                    }
                }
            });
            
            return {
                segments,
                hitPoints, // Points where lightning hits the outer globe
                startTime: currentTime,
                originAngle: startAngle,
                layer: layer,
                outerRadius: outerRadius
            };
        }

        // Check for lightning triggers and update active bolts
        function updateLightning(currentTime) {
            // Check for new lightning triggers (not every frame for performance)
            if (currentTime - lastLightningCheck > 0.1) {
                lastLightningCheck = currentTime;
                
                layers.forEach(layer => {
                    for (let i = 0; i < HEIGHTMAP_RESOLUTION; i++) {
                        if (layer.heightmap[i] > LIGHTNING_THRESHOLD) {
                            // Trigger lightning!
                            const angle = (i / HEIGHTMAP_RESOLUTION) * Math.PI * 2;
                            const bolt = generateLightningBolt(angle, layer, currentTime);
                            activeLightningBolts.push(bolt);
                            
                            // Create fireworks at each hit point where lightning touches the globe edge
                            // (No secondary lightning outside the globe - it stays contained)
                            if (bolt.hitPoints) {
                                bolt.hitPoints.forEach(hit => {
                                    // Create firework at this hit point!
                                    createFirework(hit.x, hit.y, hit.angle);
                                });
                            }
                            
                            // Clear snow in this area (destroy accumulated snow)
                            const clearRadius = 15; // Clear this many heightmap cells
                            for (let j = -clearRadius; j <= clearRadius; j++) {
                                const clearIdx = (i + j + HEIGHTMAP_RESOLUTION) % HEIGHTMAP_RESOLUTION;
                                const falloff = 1.0 - Math.abs(j) / clearRadius;
                                layer.heightmap[clearIdx] *= (1.0 - falloff * 0.9);
                            }
                            
                            // Remove accumulated snow particles in this area
                            const newPositions = [];
                            const newSizes = [];
                            let newCount = 0;
                            
                            for (let p = 0; p < layer.accumulated.positions.length; p += 2) {
                                const pAngle = layer.accumulated.positions[p];
                                const pRadius = layer.accumulated.positions[p + 1];
                                
                                // Check if particle is in the blast zone
                                let angleDiff = Math.abs(pAngle - angle);
                                angleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                                
                                const inBlastZone = angleDiff < 0.15 && pRadius < PLANET_RADIUS + 0.1;
                                
                                if (!inBlastZone) {
                                    newPositions.push(pAngle, pRadius);
                                    newSizes.push(layer.accumulated.sizes[p / 2]);
                                    newCount++;
                                }
                            }
                            
                            layer.accumulated.positions = newPositions;
                            layer.accumulated.sizes = newSizes;
                            layer.accumulated.count = newCount;
                            
                            // Update buffers
                            if (layer.accumulated.buffer && newCount > 0) {
                                gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.buffer);
                                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(newPositions), gl.STATIC_DRAW);
                                
                                gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.sizeBuffer);
                                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(newSizes), gl.STATIC_DRAW);
                            }
                        }
                    }
                });
            }
            
            // Remove expired lightning bolts
            for (let i = activeLightningBolts.length - 1; i >= 0; i--) {
                if (currentTime - activeLightningBolts[i].startTime > LIGHTNING_DURATION) {
                    activeLightningBolts.splice(i, 1);
                }
            }
        }

        // Render lightning bolts - plasma ball style with thickness variation
        function renderLightning(currentTime) {
            if (activeLightningBolts.length === 0) return;
            
            gl.useProgram(lightningProgram);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending for glow effect
            
            gl.uniform2f(lightningResolutionLocation, canvas.width, canvas.height);
            
            activeLightningBolts.forEach(bolt => {
                if (!bolt.segments || bolt.segments.length === 0) return;
                
                const age = currentTime - bolt.startTime;
                const fadeOut = 1.0 - (age / LIGHTNING_DURATION);
                const flicker = 0.7 + Math.random() * 0.3; // Random flicker
                
                // Group segments by thickness for batch rendering
                const thicknessGroups = {};
                
                bolt.segments.forEach(seg => {
                    const baseThickness = seg.thickness || 1;
                    const segRadius = seg.radius || 1.0;
                    
                    // Calculate progress toward center (0 at outer edge, 1 at planet)
                    const outerR = 1.5;
                    const innerR = PLANET_RADIUS;
                    const progressToCenter = Math.max(0, Math.min(1, 1.0 - (segRadius - innerR) / (outerR - innerR)));
                    
                    // Scale thickness based on distance from center
                    // FAT roots near planet (up to 3x), hair-thin at outer edges (10x thinner)
                    // Use exponential curve for more dramatic fat-to-thin transition
                    const radiusMultiplier = 0.015 + Math.pow(progressToCenter, 0.6) * 2.985;
                    const thickness = Math.max(1, Math.round(baseThickness * radiusMultiplier));
                    
                    if (!thicknessGroups[thickness]) {
                        thicknessGroups[thickness] = { positions: [], alphas: [], radii: [] };
                    }
                    
                    // Add slight jitter for electric effect - more jitter at outer edges
                    const jitter = 0.003 * (1.5 - progressToCenter);
                    const jx1 = seg.x1 + (Math.random() - 0.5) * jitter;
                    const jy1 = seg.y1 + (Math.random() - 0.5) * jitter;
                    const jx2 = seg.x2 + (Math.random() - 0.5) * jitter;
                    const jy2 = seg.y2 + (Math.random() - 0.5) * jitter;
                    
                    thicknessGroups[thickness].positions.push(jx1, jy1, jx2, jy2);
                    thicknessGroups[thickness].radii.push(progressToCenter);
                    
                    // Alpha based on thickness - thicker = brighter core
                    const baseAlpha = Math.min(1.0, 0.4 + thickness * 0.08);
                    const alpha = baseAlpha * fadeOut * flicker;
                    thicknessGroups[thickness].alphas.push(alpha, alpha);
                });
                
                // Render each thickness group - more passes for thicker lines
                for (const [thicknessStr, group] of Object.entries(thicknessGroups)) {
                    const thickness = parseInt(thicknessStr);
                    if (group.positions.length === 0) continue;
                    
                    // Average progress to center for this group (for glow calculation)
                    const avgProgress = group.radii.reduce((a, b) => a + b, 0) / group.radii.length;
                    
                    // Calculate number of passes based on thickness
                    // More passes for thicker (inner) segments
                    const basePasses = Math.min(Math.ceil(thickness * 1.2), 10);
                    
                    // Glow passes - more glow for fat inner segments
                    const glowPassCount = Math.ceil(1 + avgProgress * 3); // 1-4 glow layers
                    
                    // Draw the glow layer first
                    for (let glowPass = 0; glowPass < glowPassCount; glowPass++) {
                        // More glow for inner (fat) segments
                        const glowWidth = (thickness + glowPass * 1.5 + avgProgress * 2) * 0.003;
                        const passesForGlow = basePasses + glowPass * 2 + Math.floor(avgProgress * 2);
                        
                        for (let pass = 0; pass < passesForGlow; pass++) {
                            const offsetPositions = [];
                            const offsetAmount = (pass - (passesForGlow - 1) / 2) * glowWidth / passesForGlow;
                            
                            for (let i = 0; i < group.positions.length; i += 4) {
                                const x1 = group.positions[i];
                                const y1 = group.positions[i + 1];
                                const x2 = group.positions[i + 2];
                                const y2 = group.positions[i + 3];
                                
                                // Calculate perpendicular offset for line thickness
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                const len = Math.sqrt(dx * dx + dy * dy);
                                if (len > 0) {
                                    const px = -dy / len * offsetAmount;
                                    const py = dx / len * offsetAmount;
                                    offsetPositions.push(x1 + px, y1 + py, x2 + px, y2 + py);
                                } else {
                                    offsetPositions.push(x1, y1, x2, y2);
                                }
                            }
                            
                            // Glow alpha is lower - but stronger for inner bolts
                            const glowAlphas = group.alphas.map(a => a * (0.35 + avgProgress * 0.15 - glowPass * 0.06));
                            
                            // Create and bind buffers
                            const posBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(offsetPositions), gl.DYNAMIC_DRAW);
                            gl.enableVertexAttribArray(lightningPositionLocation);
                            gl.vertexAttribPointer(lightningPositionLocation, 2, gl.FLOAT, false, 0, 0);
                            
                            const alphaBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(glowAlphas), gl.DYNAMIC_DRAW);
                            gl.enableVertexAttribArray(lightningAlphaLocation);
                            gl.vertexAttribPointer(lightningAlphaLocation, 1, gl.FLOAT, false, 0, 0);
                            
                            gl.drawArrays(gl.LINES, 0, offsetPositions.length / 2);
                            
                            gl.disableVertexAttribArray(lightningPositionLocation);
                            gl.disableVertexAttribArray(lightningAlphaLocation);
                            
                            gl.deleteBuffer(posBuffer);
                            gl.deleteBuffer(alphaBuffer);
                        }
                    }
                    
                    // Draw the core (bright center) - fatter near planet
                    const coreWidth = thickness * 0.002 * (1 + avgProgress * 0.5);
                    const corePasses = Math.max(1, Math.ceil(thickness * 0.8 + avgProgress));
                    
                    for (let pass = 0; pass < corePasses; pass++) {
                        const offsetPositions = [];
                        const offsetAmount = (pass - (corePasses - 1) / 2) * coreWidth / Math.max(1, corePasses - 1);
                        
                        for (let i = 0; i < group.positions.length; i += 4) {
                            const x1 = group.positions[i];
                            const y1 = group.positions[i + 1];
                            const x2 = group.positions[i + 2];
                            const y2 = group.positions[i + 3];
                            
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const len = Math.sqrt(dx * dx + dy * dy);
                            if (len > 0 && corePasses > 1) {
                                const px = -dy / len * offsetAmount;
                                const py = dx / len * offsetAmount;
                                offsetPositions.push(x1 + px, y1 + py, x2 + px, y2 + py);
                            } else {
                                offsetPositions.push(x1, y1, x2, y2);
                            }
                        }
                        
                        const posBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(offsetPositions), gl.DYNAMIC_DRAW);
                        gl.enableVertexAttribArray(lightningPositionLocation);
                        gl.vertexAttribPointer(lightningPositionLocation, 2, gl.FLOAT, false, 0, 0);
                        
                        const alphaBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(group.alphas), gl.DYNAMIC_DRAW);
                        gl.enableVertexAttribArray(lightningAlphaLocation);
                        gl.vertexAttribPointer(lightningAlphaLocation, 1, gl.FLOAT, false, 0, 0);
                        
                        gl.drawArrays(gl.LINES, 0, offsetPositions.length / 2);
                        
                        gl.disableVertexAttribArray(lightningPositionLocation);
                        gl.disableVertexAttribArray(lightningAlphaLocation);
                        
                        gl.deleteBuffer(posBuffer);
                        gl.deleteBuffer(alphaBuffer);
                    }
                }
            });
            
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }

        function checkAndAccumulateSnow(currentTime) {
            layers.forEach(layer => {
                // Check a subset of particles each frame for performance
                const particlesToCheck = Math.min(500, layer.count);
                
                for (let i = 0; i < particlesToCheck; i++) {
                    const randomIdx = layer.startIdx + Math.floor(Math.random() * layer.count);
                    const particleKey = `${layer.name}_${randomIdx}`;
                    
                    // Skip if already accumulated
                    if (accumulatedParticles.has(particleKey)) continue;
                    
                    // Get particle data
                    const angleNorm = snowPositions[randomIdx * 3]; // 0-1
                    const speed = snowSpeeds[randomIdx];
                    const offset = snowOffsets[randomIdx];
                    const size = snowSizes[randomIdx];
                    
                    // Calculate angle with drift
                    const baseAngle = angleNorm * Math.PI * 2;
                    const drift = Math.sin(currentTime * 0.3 + offset * 10.0) * 0.1;
                    const angle = baseAngle + drift;
                    
                    // Calculate current radius (falling inward)
                    const maxRadius = 1.5;
                    const fallProgress = (currentTime * speed * layer.speedMult * 0.3 + offset) % 1.0;
                    const radius = maxRadius * (1.0 - fallProgress) + PLANET_RADIUS * fallProgress;
                    
                    // Get current snow height at this angle
                    const currentHeight = getHeightAtAngle(layer, angle);
                    const landingRadius = PLANET_RADIUS + currentHeight;
                    
                    // If particle reached the landing radius
                    if (radius <= landingRadius + 0.01) {
                        // Add multiple particles around the landing position for better coverage
                        const spreadCount = 3;
                        for (let s = 0; s < spreadCount; s++) {
                            const spreadAngle = angle + (Math.random() - 0.5) * 0.03;
                            const spreadRadius = landingRadius + (Math.random() - 0.5) * 0.005;
                            // Store as angle, radius for the shader
                            layer.accumulated.positions.push(spreadAngle, spreadRadius);
                            layer.accumulated.sizes.push(size * 2.0);
                            layer.accumulated.count++;
                        }
                        
                        // Update heightmap
                        const particleHeightContribution = size * 0.0002;
                        addSnowToHeightmap(layer, angle, particleHeightContribution);
                        
                        // Mark as accumulated
                        accumulatedParticles.add(particleKey);
                        
                        // Update buffers every 10 particles for performance
                        if (layer.accumulated.count % 10 === 0) {
                            if (!layer.accumulated.buffer) {
                                layer.accumulated.buffer = gl.createBuffer();
                                layer.accumulated.sizeBuffer = gl.createBuffer();
                            }
                            
                            gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.buffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(layer.accumulated.positions), gl.STATIC_DRAW);
                            
                            gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.sizeBuffer);
                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(layer.accumulated.sizes), gl.STATIC_DRAW);
                        }
                    }
                }
            });
        }

        let lastFrameTime = 0;
        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;
            const deltaTime = lastFrameTime > 0 ? currentTime - lastFrameTime : 0.016;
            lastFrameTime = currentTime;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Render background
            gl.useProgram(bgProgram);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, bgBuffer);
            gl.enableVertexAttribArray(bgPositionLocation);
            gl.vertexAttribPointer(bgPositionLocation, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(bgTimeLocation, currentTime);
            gl.uniform2f(bgResolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(bgPlanetRadiusLocation, PLANET_RADIUS);
            gl.uniform1f(bgGlobeRadiusLocation, GLOBE_RADIUS);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Render snow in three parallax layers
            gl.useProgram(snowProgram);
            
            // Enable blending for transparent snow
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            // Set up attributes (same for all layers)
            gl.bindBuffer(gl.ARRAY_BUFFER, snowPositionBuffer);
            gl.enableVertexAttribArray(snowPositionLocation);
            gl.vertexAttribPointer(snowPositionLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowSizeBuffer);
            gl.enableVertexAttribArray(snowSizeLocation);
            gl.vertexAttribPointer(snowSizeLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowSpeedBuffer);
            gl.enableVertexAttribArray(snowSpeedLocation);
            gl.vertexAttribPointer(snowSpeedLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, snowOffsetBuffer);
            gl.enableVertexAttribArray(snowOffsetLocation);
            gl.vertexAttribPointer(snowOffsetLocation, 1, gl.FLOAT, false, 0, 0);
            
            gl.uniform1f(snowTimeLocation, currentTime);
            gl.uniform2f(snowResolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(snowPlanetRadiusLocation, PLANET_RADIUS);
            
            // Layer 3 (furthest back - smallest, slowest, most transparent, most particles)
            gl.uniform1f(snowScaleLocation, 0.4);
            gl.uniform1f(snowDepthLocation, 0.3);
            gl.uniform1f(snowSpeedMultiplierLocation, 0.3); // 30% speed
            gl.drawArrays(gl.POINTS, 0, layer3Count);
            
            // Layer 2 (middle - medium size and speed)
            gl.uniform1f(snowScaleLocation, 0.7);
            gl.uniform1f(snowDepthLocation, 0.6);
            gl.uniform1f(snowSpeedMultiplierLocation, 0.6); // 60% speed
            gl.drawArrays(gl.POINTS, layer3Count, layer2Count);
            
            // Layer 1 (front - original size and full opacity and speed)
            gl.uniform1f(snowScaleLocation, 1.0);
            gl.uniform1f(snowDepthLocation, 1.0);
            gl.uniform1f(snowSpeedMultiplierLocation, 1.0); // 100% speed
            gl.drawArrays(gl.POINTS, layer3Count + layer2Count, layer1Count);
            
            gl.disable(gl.BLEND);

            // Check and accumulate snow
            checkAndAccumulateSnow(currentTime);

            // Redistribute snow every frame to create natural spreading
            layers.forEach(layer => redistributeSnow(layer));

            // Update and check for lightning triggers
            updateLightning(currentTime);

            // Render accumulated snow
            gl.useProgram(accProgram);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            gl.uniform2f(accResolutionLocation, canvas.width, canvas.height);

            // Render each layer's accumulated snow
            layers.forEach(layer => {
                if (layer.accumulated.count > 0 && layer.accumulated.buffer) {
                    gl.uniform1f(accScaleLocation, layer.scale);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.buffer);
                    gl.enableVertexAttribArray(accPositionLocation);
                    gl.vertexAttribPointer(accPositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, layer.accumulated.sizeBuffer);
                    gl.enableVertexAttribArray(accSizeLocation);
                    gl.vertexAttribPointer(accSizeLocation, 1, gl.FLOAT, false, 0, 0);
                    
                    gl.drawArrays(gl.POINTS, 0, layer.accumulated.count);
                }
            });
            
            gl.disable(gl.BLEND);

            // Render lightning bolts
            renderLightning(currentTime);
            
            // Update and render fireworks
            updateFireworks(currentTime, deltaTime);
            renderFireworks();
            
            // Render sprite hit effects (backward compatibility)
            renderSprites(currentTime);

            requestAnimationFrame(render);
        }

        render();
        
        // Initialize animated holiday text
        (function initHolidayText() {
            const text = "Happy Holidays My Dear Tuvis!";
            const container = document.getElementById('holiday-text');
            
            // Create individual spans for each character with staggered animation delay
            text.split('').forEach((char, index) => {
                const span = document.createElement('span');
                span.textContent = char === ' ' ? '\u00A0' : char; // Use non-breaking space
                span.style.animationDelay = (index * 0.08) + 's';
                container.appendChild(span);
            });
        })();
    </script>

</body></html>