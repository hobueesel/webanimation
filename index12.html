<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Index12 - Jellyfish Galaxy</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --glass:bg rgba(6,10,26,0.54);
      --border:rgba(255,255,255,0.1);
    }
    * { box-sizing:border-box; }
    body {
      margin:0;
      min-height:100vh;
      font-family:'Space Grotesk',"Trebuchet MS",sans-serif;
      background:radial-gradient(circle at 20% 20%,#05101a 0%,#020610 55%,#010103 100%);
      color:#f7f9ff;
      overflow:hidden;
    }
    canvas {
      display:block;
      width:100vw;
      height:100vh;
      outline:none;
    }
    .overlay {
      position:fixed;
      inset:auto auto 28px 28px;
      max-width:320px;
      background:var(--glass);
      border:1px solid var(--border);
      border-radius:18px;
      padding:20px 22px 18px;
      backdrop-filter:blur(18px);
      box-shadow:0 25px 60px rgba(0,0,0,0.45);
    }
    h1 {
      margin:0 0 6px;
      font-size:1.65rem;
      letter-spacing:0.04em;
    }
    p {
      margin:0;
      font-size:0.95rem;
      line-height:1.35;
      color:rgba(247,249,255,0.75);
    }
    .legend {
      margin:16px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px;
      font-size:0.82rem;
    }
    .legend li {
      display:flex;
      align-items:center;
      gap:8px;
      color:rgba(247,249,255,0.75);
    }
    .chip {
      width:14px;
      height:14px;
      border-radius:7px;
      background:var(--tone,#fff);
      box-shadow:0 0 12px var(--tone,#fff);
      flex-shrink:0;
    }
    @media (max-width:640px) {
      .overlay {
        inset:auto 18px 18px auto;
        max-width:calc(100vw - 36px);
      }
      h1 { font-size:1.35rem; }
      .legend { grid-template-columns:repeat(3,minmax(0,1fr)); }
    }
  </style>
</head>
<body>
  <canvas id="universe"></canvas>
  <section class="overlay">
    <h1>ðŸª¼ Jellyfish Galaxy</h1>
    <p>Drag to drift through the cosmos, scroll to float closer. Watch the cosmic jellyfish pulse through the stellar deep!</p>
    <ul class="legend">
      <li><span class="chip" style="--tone:#f8c56d"></span>Sun Jelly</li>
      <li><span class="chip" style="--tone:#c5b199"></span>Mercury Moon</li>
      <li><span class="chip" style="--tone:#f5a971"></span>Venus Bloom</li>
      <li><span class="chip" style="--tone:#5eb7ff"></span>Earth Drift</li>
      <li><span class="chip" style="--tone:#f16b5b"></span>Mars Pulse</li>
      <li><span class="chip" style="--tone:#efd08a"></span>Jupiter Giant</li>
      <li><span class="chip" style="--tone:#d9b578"></span>Saturn Bell</li>
      <li><span class="chip" style="--tone:#74f0d4"></span>Uranus Glow</li>
      <li><span class="chip" style="--tone:#60a8ff"></span>Neptune Deep</li>
    </ul>
  </section>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    const canvas = document.getElementById('universe');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.35;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020508);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(-180, 120, 260);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 60;
    controls.maxDistance = 800;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.35;

    const G = 0.00045;
    const SUN_MASS = 420000;
    const TIME_ACCEL = 35;
    const MAX_COMETS = 4;
    const COMET_MIN_DELAY = 12;
    const COMET_MAX_DELAY = 24;
    const COMET_TRAIL_SEGMENTS = 140;
    const COMET_MAX_DISTANCE = 700;
    const PLANET_TRAIL_SEGMENTS = 220;

    // Store all jellyfish for tentacle animation
    const allJellyfish = [];

    // Create a jellyfish mesh with transparent bell and dangling tentacles
    function createJellyfishMesh(size, color, emissiveIntensity = 0.8, numTentacles = 8) {
      const group = new THREE.Group();
      const baseColor = new THREE.Color(color);
      const emissiveColor = baseColor.clone().multiplyScalar(0.7);

      // Bell (dome shape) - the main body
      const bellGeom = new THREE.SphereGeometry(size, 32, 24, 0, Math.PI * 2, 0, Math.PI * 0.6);
      const bellMat = new THREE.MeshPhysicalMaterial({
        color: baseColor,
        roughness: 0.1,
        metalness: 0.0,
        emissive: emissiveColor,
        emissiveIntensity: emissiveIntensity,
        transparent: true,
        opacity: 0.45,
        transmission: 0.6,
        thickness: 1.5,
        clearcoat: 1,
        clearcoatRoughness: 0.1,
        side: THREE.DoubleSide,
        envMapIntensity: 1.5
      });
      const bell = new THREE.Mesh(bellGeom, bellMat);
      bell.rotation.x = Math.PI;
      group.add(bell);

      // Inner bell (slightly smaller, more opaque core)
      const innerBellGeom = new THREE.SphereGeometry(size * 0.7, 24, 18, 0, Math.PI * 2, 0, Math.PI * 0.5);
      const innerBellMat = new THREE.MeshPhysicalMaterial({
        color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.3),
        roughness: 0.2,
        emissive: emissiveColor,
        emissiveIntensity: emissiveIntensity * 1.5,
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide
      });
      const innerBell = new THREE.Mesh(innerBellGeom, innerBellMat);
      innerBell.rotation.x = Math.PI;
      innerBell.position.y = size * 0.15;
      group.add(innerBell);

      // Frilly edge around bell
      const frillyGeom = new THREE.TorusGeometry(size * 0.85, size * 0.12, 8, 32);
      const frillyMat = new THREE.MeshPhysicalMaterial({
        color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.4),
        roughness: 0.3,
        emissive: emissiveColor,
        emissiveIntensity: emissiveIntensity * 0.8,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      const frilly = new THREE.Mesh(frillyGeom, frillyMat);
      frilly.rotation.x = Math.PI / 2;
      frilly.position.y = -size * 0.45;
      group.add(frilly);

      // Tentacles group
      const tentaclesGroup = new THREE.Group();
      tentaclesGroup.position.y = -size * 0.5;
      group.add(tentaclesGroup);

      const tentacles = [];
      
      // Create wavy tentacles using tube geometry
      for (let i = 0; i < numTentacles; i++) {
        const angle = (i / numTentacles) * Math.PI * 2;
        const radius = size * 0.6;
        const startX = Math.cos(angle) * radius;
        const startZ = Math.sin(angle) * radius;
        
        // Create a curved path for the tentacle
        const tentacleLength = size * (2.5 + Math.random() * 1.5);
        const segments = 12;
        const points = [];
        
        for (let j = 0; j <= segments; j++) {
          const t = j / segments;
          const y = -t * tentacleLength;
          const wave = Math.sin(t * Math.PI * 2) * size * 0.3;
          points.push(new THREE.Vector3(
            startX + wave * Math.cos(angle + Math.PI / 2),
            y,
            startZ + wave * Math.sin(angle + Math.PI / 2)
          ));
        }
        
        const curve = new THREE.CatmullRomCurve3(points);
        const tentacleGeom = new THREE.TubeGeometry(curve, 20, size * 0.06 * (1 - 0.3 * Math.random()), 8, false);
        const tentacleMat = new THREE.MeshPhysicalMaterial({
          color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.2),
          roughness: 0.3,
          emissive: emissiveColor,
          emissiveIntensity: emissiveIntensity * 0.6,
          transparent: true,
          opacity: 0.4,
          side: THREE.DoubleSide
        });
        const tentacle = new THREE.Mesh(tentacleGeom, tentacleMat);
        tentaclesGroup.add(tentacle);
        
        tentacles.push({
          mesh: tentacle,
          basePoints: points.map(p => p.clone()),
          angle: angle,
          length: tentacleLength,
          phase: Math.random() * Math.PI * 2,
          speed: 0.8 + Math.random() * 0.4
        });
      }

      // Short frilly oral arms near center
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2 + Math.PI / 8;
        const armLength = size * 1.2;
        const points = [];
        
        for (let j = 0; j <= 8; j++) {
          const t = j / 8;
          points.push(new THREE.Vector3(
            Math.cos(angle) * size * 0.2 * (1 + t * 0.5),
            -t * armLength,
            Math.sin(angle) * size * 0.2 * (1 + t * 0.5)
          ));
        }
        
        const curve = new THREE.CatmullRomCurve3(points);
        const armGeom = new THREE.TubeGeometry(curve, 12, size * 0.1, 6, false);
        const armMat = new THREE.MeshPhysicalMaterial({
          color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.5),
          roughness: 0.2,
          emissive: emissiveColor,
          emissiveIntensity: emissiveIntensity,
          transparent: true,
          opacity: 0.55
        });
        const arm = new THREE.Mesh(armGeom, armMat);
        tentaclesGroup.add(arm);
        
        tentacles.push({
          mesh: arm,
          basePoints: points.map(p => p.clone()),
          angle: angle,
          length: armLength,
          phase: Math.random() * Math.PI * 2,
          speed: 1.2 + Math.random() * 0.3,
          isArm: true
        });
      }

      // Store tentacle data for animation
      group.userData.tentacles = tentacles;
      group.userData.tentaclesGroup = tentaclesGroup;
      group.userData.bell = bell;
      group.userData.pulsePhase = Math.random() * Math.PI * 2;
      
      allJellyfish.push(group);

      return group;
    }

    // Create comet jellyfish (smaller, trailing)
    function createCometJellyfish(size = 1.4) {
      const group = new THREE.Group();
      
      // Small translucent bell
      const bellGeom = new THREE.SphereGeometry(size, 20, 16, 0, Math.PI * 2, 0, Math.PI * 0.55);
      const bellMat = new THREE.MeshPhysicalMaterial({
        color: 0xd8f7ff,
        emissive: 0x9fdfff,
        emissiveIntensity: 2.5,
        roughness: 0.1,
        transparent: true,
        opacity: 0.5,
        transmission: 0.7,
        thickness: 1,
        clearcoat: 1,
        side: THREE.DoubleSide
      });
      const bell = new THREE.Mesh(bellGeom, bellMat);
      bell.rotation.x = Math.PI;
      group.add(bell);

      // Glowing core
      const coreGeom = new THREE.SphereGeometry(size * 0.5, 16, 12);
      const coreMat = new THREE.MeshBasicMaterial({
        color: 0xaef4ff,
        transparent: true,
        opacity: 0.6
      });
      const core = new THREE.Mesh(coreGeom, coreMat);
      core.position.y = size * 0.2;
      group.add(core);

      // Trailing tentacles
      const tentaclesGroup = new THREE.Group();
      tentaclesGroup.position.y = -size * 0.4;
      group.add(tentaclesGroup);

      const tentacles = [];
      const numTentacles = 6;
      
      for (let i = 0; i < numTentacles; i++) {
        const angle = (i / numTentacles) * Math.PI * 2;
        const radius = size * 0.5;
        const tentacleLength = size * (3 + Math.random() * 2);
        const points = [];
        
        for (let j = 0; j <= 10; j++) {
          const t = j / 10;
          points.push(new THREE.Vector3(
            Math.cos(angle) * radius * (1 - t * 0.3),
            -t * tentacleLength,
            Math.sin(angle) * radius * (1 - t * 0.3)
          ));
        }
        
        const curve = new THREE.CatmullRomCurve3(points);
        const tentacleGeom = new THREE.TubeGeometry(curve, 16, size * 0.04, 6, false);
        const tentacleMat = new THREE.MeshPhysicalMaterial({
          color: 0xaef4ff,
          emissive: 0x7fefff,
          emissiveIntensity: 2,
          roughness: 0.2,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide
        });
        const tentacle = new THREE.Mesh(tentacleGeom, tentacleMat);
        tentaclesGroup.add(tentacle);
        
        tentacles.push({
          mesh: tentacle,
          basePoints: points.map(p => p.clone()),
          angle: angle,
          length: tentacleLength,
          phase: Math.random() * Math.PI * 2,
          speed: 1.5 + Math.random() * 0.5
        });
      }

      group.userData.tentacles = tentacles;
      group.userData.tentaclesGroup = tentaclesGroup;
      group.userData.bell = bell;
      group.userData.pulsePhase = Math.random() * Math.PI * 2;
      
      allJellyfish.push(group);

      return group;
    }

    // Animate tentacles
    function animateTentacles(jellyGroup, time, velocity = null) {
      const tentacles = jellyGroup.userData.tentacles;
      if (!tentacles) return;

      const bell = jellyGroup.userData.bell;
      const pulsePhase = jellyGroup.userData.pulsePhase;
      
      // Pulsing bell animation
      const pulse = 1 + Math.sin(time * 2 + pulsePhase) * 0.08;
      if (bell) {
        bell.scale.set(pulse, 1 + (1 - pulse) * 0.5, pulse);
      }

      for (const t of tentacles) {
        const points = [];
        const basePoints = t.basePoints;
        
        for (let i = 0; i < basePoints.length; i++) {
          const bp = basePoints[i];
          const progress = i / (basePoints.length - 1);
          
          // Wave motion increases along tentacle length
          const waveAmp = progress * progress * t.length * 0.15;
          const waveFreq = 3;
          const phase = time * t.speed + t.phase;
          
          // Add velocity-based trailing if moving
          let velOffset = { x: 0, z: 0 };
          if (velocity && velocity.length() > 0.1) {
            const velNorm = velocity.clone().normalize();
            velOffset.x = -velNorm.x * progress * progress * t.length * 0.3;
            velOffset.z = -velNorm.z * progress * progress * t.length * 0.3;
          }
          
          points.push(new THREE.Vector3(
            bp.x + Math.sin(phase + progress * waveFreq) * waveAmp + velOffset.x,
            bp.y + Math.cos(phase * 0.7 + progress * 2) * waveAmp * 0.3,
            bp.z + Math.cos(phase + progress * waveFreq) * waveAmp + velOffset.z
          ));
        }
        
        // Rebuild tube geometry
        const curve = new THREE.CatmullRomCurve3(points);
        const newGeom = new THREE.TubeGeometry(
          curve, 
          t.isArm ? 12 : 20, 
          t.mesh.geometry.parameters.radius || 0.1, 
          t.isArm ? 6 : 8, 
          false
        );
        t.mesh.geometry.dispose();
        t.mesh.geometry = newGeom;
      }
    }

    // Bubble particles (like stars but bubbly)
    const bubbleGeometry = new THREE.BufferGeometry();
    const bubbleVertices = [];
    for (let i = 0; i < 1500; i++) {
      bubbleVertices.push(
        THREE.MathUtils.randFloatSpread(3000),
        THREE.MathUtils.randFloatSpread(3000),
        THREE.MathUtils.randFloatSpread(3000)
      );
    }
    bubbleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bubbleVertices, 3));
    const bubbleMaterial = new THREE.PointsMaterial({ 
      color: 0xaaddff, 
      size: 2.5, 
      sizeAttenuation: true, 
      transparent: true, 
      opacity: 0.5 
    });
    const bubbles = new THREE.Points(bubbleGeometry, bubbleMaterial);
    scene.add(bubbles);

    const ambient = new THREE.AmbientLight(0x4a6a8a, 0.85);
    scene.add(ambient);

    const hemiLight = new THREE.HemisphereLight(0x6c9dff, 0x021020, 0.7);
    scene.add(hemiLight);

    const rimLight = new THREE.DirectionalLight(0x88c4ff, 1.0);
    rimLight.position.set(120, 160, -80);
    scene.add(rimLight);

    // Sun Jellyfish (big golden cosmic jelly)
    const sunJelly = createJellyfishMesh(15, 0xfff1c0, 2.2, 12);
    sunJelly.scale.set(1.3, 1.3, 1.3);
    scene.add(sunJelly);

    const sunLight = new THREE.PointLight(0xfff0c1, 4.5, 0, 2);
    sunLight.position.copy(sunJelly.position);
    scene.add(sunLight);

    const planetConfigs = [
      { name: 'Mercury', radius: 32, size: 2.2, color: 0xc5b199, speed: 1.25, mass: 6 },
      { name: 'Venus', radius: 50, size: 4, color: 0xf5a971, speed: 1.1, mass: 12 },
      { name: 'Earth', radius: 70, size: 4.6, color: 0x5eb7ff, speed: 1.0, mass: 14, tilt: 6 },
      { name: 'Mars', radius: 90, size: 3.2, color: 0xf16b5b, speed: 0.85, mass: 7 },
      { name: 'Jupiter', radius: 130, size: 10, color: 0xefd08a, speed: 0.55, mass: 70 },
      { name: 'Saturn', radius: 170, size: 8.5, color: 0xd9b578, speed: 0.45, mass: 60, rings: { inner: 11, outer: 15 } },
      { name: 'Uranus', radius: 200, size: 6.3, color: 0x74f0d4, speed: 0.3, mass: 40 },
      { name: 'Neptune', radius: 230, size: 6.1, color: 0x60a8ff, speed: 0.28, mass: 45 }
    ];

    function createOrbit(radius) {
      const points = [];
      const segments = 256;
      for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(theta) * radius, 0, Math.sin(theta) * radius));
      }
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x1a3050, transparent: true, opacity: 0.25 });
      const line = new THREE.LineLoop(geometry, material);
      scene.add(line);
    }

    function orbitalVelocity(radius, speedFactor = 1) {
      return Math.sqrt((G * SUN_MASS) / radius) * speedFactor;
    }

    const planetStates = planetConfigs.map(cfg => {
      // More tentacles for bigger jellyfish
      const numTentacles = Math.max(5, Math.floor(cfg.size * 0.8));
      const mesh = createJellyfishMesh(cfg.size, cfg.color, 0.8, numTentacles);
      mesh.userData = cfg;

      // Saturn gets glowing ring of small particles
      if (cfg.rings) {
        const ringGeometry = new THREE.TorusGeometry(cfg.rings.outer * 1.2, 0.8, 8, 64);
        const ringMat = new THREE.MeshPhysicalMaterial({ 
          color: 0xf6e1b1, 
          emissive: 0xd9b578,
          emissiveIntensity: 0.5,
          transparent: true, 
          opacity: 0.35,
          side: THREE.DoubleSide
        });
        const rings = new THREE.Mesh(ringGeometry, ringMat);
        rings.rotation.x = Math.PI / 2;
        mesh.add(rings);
      }

      createOrbit(cfg.radius);
      scene.add(mesh);

      const position = new THREE.Vector3(cfg.radius, 0, 0);
      const velocity = new THREE.Vector3(0, 0, orbitalVelocity(cfg.radius, cfg.speed));
      mesh.position.copy(position);

      const trailPositions = new Float32Array(PLANET_TRAIL_SEGMENTS * 3);
      for (let i = 0; i < PLANET_TRAIL_SEGMENTS; i++) {
        trailPositions[i * 3] = position.x;
        trailPositions[i * 3 + 1] = position.y;
        trailPositions[i * 3 + 2] = position.z;
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const baseColor = new THREE.Color(cfg.color);
      const trailMaterial = new THREE.LineBasicMaterial({
        color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.2).getHex(),
        transparent: true,
        opacity: 0.28
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      trail.frustumCulled = false;
      scene.add(trail);

      return {
        cfg,
        mesh,
        position,
        velocity,
        mass: cfg.mass,
        wobbleSeed: Math.random() * Math.PI * 2,
        trail,
        trailGeometry,
        trailPositions,
        swimPhase: Math.random() * Math.PI * 2
      };
    });

    // Moon jellyfish (tiny translucent jelly)
    const moonJelly = createJellyfishMesh(1.2, 0xf6f3ef, 0.5, 4);
    moonJelly.scale.set(0.8, 0.8, 0.8);
    scene.add(moonJelly);

    const comets = [];
    let cometSpawnTimer = 6;
    const impactFlares = [];
    let moonPhase = 0;
    let simTime = 0;

    function computeGravity(sourcePos, targetPos, mass) {
      const dir = new THREE.Vector3().copy(sourcePos).sub(targetPos);
      const distSq = Math.max(dir.lengthSq(), 25);
      return dir.multiplyScalar((G * mass) / Math.pow(distSq, 1.5));
    }

    function updatePlanetTrail(state) {
      const pos = state.trailPositions;
      for (let i = pos.length - 1; i >= 3; i -= 3) {
        pos[i] = pos[i - 3];
        pos[i - 1] = pos[i - 4];
        pos[i - 2] = pos[i - 5];
      }
      pos[0] = state.mesh.position.x;
      pos[1] = state.mesh.position.y;
      pos[2] = state.mesh.position.z;
      state.trailGeometry.attributes.position.needsUpdate = true;
    }

    function updatePlanets(dt) {
      const time = simTime * 0.03;
      for (const state of planetStates) {
        const accel = computeGravity(sunJelly.position, state.position, SUN_MASS);
        state.velocity.addScaledVector(accel, dt);
        state.position.addScaledVector(state.velocity, dt);
        const wobble = state.cfg.tilt ? Math.sin(state.wobbleSeed + simTime * 0.12) * state.cfg.tilt : 0;
        
        // Gentle floating motion
        state.swimPhase += dt * 0.08;
        const floatWobble = Math.sin(state.swimPhase) * 2;
        
        state.mesh.position.set(state.position.x, wobble + floatWobble, state.position.z);
        
        // Jellyfish slowly rotate as they drift
        state.mesh.rotation.y += dt * 0.003;
        
        // Gentle bobbing tilt
        state.mesh.rotation.x = Math.sin(state.swimPhase * 0.7) * 0.08;
        state.mesh.rotation.z = Math.cos(state.swimPhase * 0.5) * 0.06;
        
        // Animate tentacles with velocity trailing
        animateTentacles(state.mesh, time, state.velocity);
        
        updatePlanetTrail(state);
      }
    }

    function updateMoon(dt) {
      const earth = planetStates.find(state => state.cfg.name === 'Earth');
      if (!earth) return;
      moonPhase += dt * 0.35;
      const moonX = earth.position.x + Math.cos(moonPhase) * 12;
      const moonZ = earth.position.z + Math.sin(moonPhase) * 12;
      moonJelly.position.set(
        moonX,
        earth.mesh.position.y + Math.sin(moonPhase * 1.5) * 2,
        moonZ
      );
      // Gentle rotation
      moonJelly.rotation.y += dt * 0.01;
      moonJelly.rotation.x = Math.sin(moonPhase) * 0.1;
      
      // Animate moon tentacles
      const moonVel = new THREE.Vector3(-Math.sin(moonPhase), 0, Math.cos(moonPhase)).multiplyScalar(0.5);
      animateTentacles(moonJelly, simTime * 0.03, moonVel);
    }

    function updateSunJelly(dt) {
      // Gentle pulsing for the sun jellyfish
      sunJelly.rotation.y += 0.001 * dt;
      sunJelly.position.y = Math.sin(simTime * 0.03) * 3;
      sunJelly.rotation.x = Math.sin(simTime * 0.04) * 0.03;
      sunJelly.rotation.z = Math.cos(simTime * 0.05) * 0.03;
      
      // Animate sun tentacles
      animateTentacles(sunJelly, simTime * 0.02, null);
    }

    function spawnComet() {
      const startAngle = Math.random() * Math.PI * 2;
      const radius = THREE.MathUtils.randFloat(260, 360);
      const height = THREE.MathUtils.randFloat(-20, 20);
      const start = new THREE.Vector3(
        Math.cos(startAngle) * radius,
        height,
        Math.sin(startAngle) * radius
      );
      const toSun = new THREE.Vector3().copy(sunJelly.position).sub(start).normalize();
      const tangent = new THREE.Vector3(-toSun.z, THREE.MathUtils.randFloat(-0.15, 0.15), toSun.x).normalize();
      const velocity = toSun.multiplyScalar(THREE.MathUtils.randFloat(1.2, 1.9))
        .add(tangent.multiplyScalar(THREE.MathUtils.randFloat(1.2, 2.4)));

      const cometMesh = createCometJellyfish(1.4);
      cometMesh.position.copy(start);
      scene.add(cometMesh);

      const trailPositions = new Float32Array(COMET_TRAIL_SEGMENTS * 3);
      for (let i = 0; i < COMET_TRAIL_SEGMENTS; i++) {
        trailPositions[i * 3] = start.x;
        trailPositions[i * 3 + 1] = start.y;
        trailPositions[i * 3 + 2] = start.z;
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailLine = new THREE.Line(
        trailGeometry,
        new THREE.LineBasicMaterial({ color: 0x9ae5ff, transparent: true, opacity: 0.7 })
      );
      scene.add(trailLine);

      comets.push({
        mesh: cometMesh,
        position: start,
        velocity,
        trailGeometry,
        trailPositions,
        trailLine,
        alive: true,
        swimPhase: Math.random() * Math.PI * 2
      });
    }

    function updateCometTrail(comet) {
      const pos = comet.trailPositions;
      for (let i = pos.length - 1; i >= 3; i -= 3) {
        pos[i] = pos[i - 3];
        pos[i - 1] = pos[i - 4];
        pos[i - 2] = pos[i - 5];
      }
      pos[0] = comet.position.x;
      pos[1] = comet.position.y;
      pos[2] = comet.position.z;
      comet.trailGeometry.attributes.position.needsUpdate = true;
    }

    function createImpactFlash(position, color) {
      // Bubble burst effect
      const burstGroup = new THREE.Group();
      for (let i = 0; i < 8; i++) {
        const bubble = new THREE.Mesh(
          new THREE.SphereGeometry(1.5, 12, 12),
          new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 })
        );
        const angle = (i / 8) * Math.PI * 2;
        bubble.position.set(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
        burstGroup.add(bubble);
      }
      burstGroup.position.copy(position);
      scene.add(burstGroup);
      impactFlares.push({ mesh: burstGroup, life: 1.2, isBurst: true });
    }

    function updateFlares(dt) {
      for (let i = impactFlares.length - 1; i >= 0; i--) {
        const flare = impactFlares[i];
        flare.life -= dt * 0.8;
        flare.mesh.scale.addScalar(dt * 0.8);
        if (flare.isBurst) {
          flare.mesh.children.forEach(child => {
            child.material.opacity = Math.max(flare.life / 1.2, 0);
          });
        } else {
          flare.mesh.material.opacity = Math.max(flare.life / 1.2, 0);
        }
        if (flare.life <= 0) {
          scene.remove(flare.mesh);
          if (flare.isBurst) {
            flare.mesh.children.forEach(child => {
              child.geometry.dispose();
              child.material.dispose();
            });
          } else {
            flare.mesh.geometry.dispose();
            flare.mesh.material.dispose();
          }
          impactFlares.splice(i, 1);
        }
      }
    }

    function disposeComet(comet) {
      scene.remove(comet.mesh);
      scene.remove(comet.trailLine);
      
      // Remove from jellyfish tracking array
      const jellyIndex = allJellyfish.indexOf(comet.mesh);
      if (jellyIndex > -1) {
        allJellyfish.splice(jellyIndex, 1);
      }
      
      comet.mesh.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      comet.trailGeometry.dispose();
      comet.trailLine.material.dispose();
    }

    function updateComets(dt) {
      cometSpawnTimer -= dt;
      if (cometSpawnTimer <= 0 && comets.length < MAX_COMETS) {
        spawnComet();
        cometSpawnTimer = THREE.MathUtils.randFloat(COMET_MIN_DELAY, COMET_MAX_DELAY);
      }

      for (let i = comets.length - 1; i >= 0; i--) {
        const comet = comets[i];
        let acceleration = computeGravity(sunJelly.position, comet.position, SUN_MASS);
        for (const state of planetStates) {
          const dir = new THREE.Vector3().copy(state.position).sub(comet.position);
          const distSq = Math.max(dir.lengthSq(), 9);
          const grav = dir.multiplyScalar((G * state.mass * 4000) / Math.pow(distSq, 1.5));
          acceleration.add(grav);
          if (Math.sqrt(distSq) < state.cfg.size + 1.8) {
            comet.alive = false;
            createImpactFlash(state.position, state.cfg.color);
            break;
          }
        }

        comet.velocity.addScaledVector(acceleration, dt);
        comet.position.addScaledVector(comet.velocity, dt);
        comet.mesh.position.copy(comet.position);
        
        // Floating motion for comet jellyfish
        comet.swimPhase += dt * 0.2;
        comet.mesh.position.y += Math.sin(comet.swimPhase) * 0.3;
        
        // Gentle rotation
        comet.mesh.rotation.y += dt * 0.005;
        comet.mesh.rotation.x = Math.sin(comet.swimPhase) * 0.1;
        comet.mesh.rotation.z = Math.cos(comet.swimPhase * 0.7) * 0.08;
        
        // Animate comet tentacles trailing behind
        animateTentacles(comet.mesh, simTime * 0.03, comet.velocity);
        
        updateCometTrail(comet);

        if (!comet.alive || comet.position.length() > COMET_MAX_DISTANCE) {
          disposeComet(comet);
          comets.splice(i, 1);
        }
      }
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(clock.getDelta(), 0.05);
      const dt = delta * TIME_ACCEL;
      simTime += dt;

      updatePlanets(dt);
      updateMoon(dt);
      updateComets(dt);
      updateFlares(dt);
      updateSunJelly(dt);

      // Gentle bubble movement
      bubbles.rotation.y += 0.0001 * dt;
      
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      const { innerWidth, innerHeight } = window;
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
