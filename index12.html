<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Index12 - Fish Ocean in Space</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --glass:bg rgba(6,10,26,0.54);
      --border:rgba(255,255,255,0.1);
    }
    * { box-sizing:border-box; }
    body {
      margin:0;
      min-height:100vh;
      font-family:'Space Grotesk',"Trebuchet MS",sans-serif;
      background:radial-gradient(circle at 20% 20%,#0a1a2a 0%,#030812 55%,#010205 100%);
      color:#f7f9ff;
      overflow:hidden;
    }
    canvas {
      display:block;
      width:100vw;
      height:100vh;
      outline:none;
    }
    .overlay {
      position:fixed;
      inset:auto auto 28px 28px;
      max-width:320px;
      background:var(--glass);
      border:1px solid var(--border);
      border-radius:18px;
      padding:20px 22px 18px;
      backdrop-filter:blur(18px);
      box-shadow:0 25px 60px rgba(0,0,0,0.45);
    }
    h1 {
      margin:0 0 6px;
      font-size:1.65rem;
      letter-spacing:0.04em;
    }
    p {
      margin:0;
      font-size:0.95rem;
      line-height:1.35;
      color:rgba(247,249,255,0.75);
    }
    .legend {
      margin:16px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px;
      font-size:0.82rem;
    }
    .legend li {
      display:flex;
      align-items:center;
      gap:8px;
      color:rgba(247,249,255,0.75);
    }
    .chip {
      width:14px;
      height:14px;
      border-radius:7px;
      background:var(--tone,#fff);
      box-shadow:0 0 12px var(--tone,#fff);
      flex-shrink:0;
    }
    @media (max-width:640px) {
      .overlay {
        inset:auto 18px 18px auto;
        max-width:calc(100vw - 36px);
      }
      h1 { font-size:1.35rem; }
      .legend { grid-template-columns:repeat(3,minmax(0,1fr)); }
    }
  </style>
</head>
<body>
  <canvas id="universe"></canvas>
  <section class="overlay">
    <h1>üêü Cosmic Aquarium</h1>
    <p>Drag to swim around, scroll to dive deeper. Watch the cosmic fish drift through the stellar ocean!</p>
    <ul class="legend">
      <li><span class="chip" style="--tone:#f8c56d"></span>Sunfish</li>
      <li><span class="chip" style="--tone:#c5b199"></span>Mercury Minnow</li>
      <li><span class="chip" style="--tone:#f5a971"></span>Venus Goldfish</li>
      <li><span class="chip" style="--tone:#5eb7ff"></span>Earth Bluefish</li>
      <li><span class="chip" style="--tone:#f16b5b"></span>Mars Redfish</li>
      <li><span class="chip" style="--tone:#efd08a"></span>Jupiter Whale</li>
      <li><span class="chip" style="--tone:#d9b578"></span>Saturn Angelfish</li>
      <li><span class="chip" style="--tone:#74f0d4"></span>Uranus Tetra</li>
      <li><span class="chip" style="--tone:#60a8ff"></span>Neptune Betta</li>
    </ul>
  </section>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.159/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

    const canvas = document.getElementById('universe');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.35;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020508);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(-180, 120, 260);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 60;
    controls.maxDistance = 800;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.35;

    const G = 0.00045;
    const SUN_MASS = 420000;
    const TIME_ACCEL = 35;
    const MAX_COMETS = 4;
    const COMET_MIN_DELAY = 12;
    const COMET_MAX_DELAY = 24;
    const COMET_TRAIL_SEGMENTS = 140;
    const COMET_MAX_DISTANCE = 700;
    const PLANET_TRAIL_SEGMENTS = 220;

    // Create fish geometry
    function createFishGeometry(scale = 1, detail = 1) {
      const shape = new THREE.Shape();
      
      // Fish body outline
      shape.moveTo(0, 0);
      shape.quadraticCurveTo(0.6 * scale, 0.4 * scale, 1.2 * scale, 0);
      shape.quadraticCurveTo(1.4 * scale, -0.15 * scale, 1.6 * scale, -0.3 * scale);
      shape.lineTo(2 * scale, 0);
      shape.lineTo(1.6 * scale, 0.3 * scale);
      shape.quadraticCurveTo(1.4 * scale, 0.15 * scale, 1.2 * scale, 0);
      shape.quadraticCurveTo(0.6 * scale, -0.4 * scale, 0, 0);

      const extrudeSettings = {
        steps: 1,
        depth: 0.3 * scale,
        bevelEnabled: true,
        bevelThickness: 0.15 * scale,
        bevelSize: 0.1 * scale,
        bevelSegments: Math.ceil(3 * detail)
      };

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.center();
      geometry.rotateY(Math.PI / 2);
      return geometry;
    }

    // Create a more detailed 3D fish mesh
    function createFishMesh(size, color, emissiveIntensity = 0.6) {
      const group = new THREE.Group();
      const baseColor = new THREE.Color(color);
      const emissiveColor = baseColor.clone().multiplyScalar(0.55);

      // Body (elongated ellipsoid)
      const bodyGeom = new THREE.SphereGeometry(size, 32, 24);
      bodyGeom.scale(1.8, 0.7, 0.5);
      const bodyMat = new THREE.MeshPhysicalMaterial({
        color: baseColor,
        roughness: 0.3,
        metalness: 0.15,
        emissive: emissiveColor,
        emissiveIntensity: emissiveIntensity,
        clearcoat: 0.5,
        clearcoatRoughness: 0.3
      });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      group.add(body);

      // Head (slightly larger front)
      const headGeom = new THREE.SphereGeometry(size * 0.6, 24, 18);
      headGeom.scale(0.8, 0.9, 0.8);
      const headMat = bodyMat.clone();
      const head = new THREE.Mesh(headGeom, headMat);
      head.position.x = size * 1.2;
      group.add(head);

      // Tail fin
      const tailShape = new THREE.Shape();
      tailShape.moveTo(0, 0);
      tailShape.lineTo(-size * 0.8, size * 0.6);
      tailShape.quadraticCurveTo(-size * 0.5, 0, -size * 0.8, -size * 0.6);
      tailShape.lineTo(0, 0);
      
      const tailGeom = new THREE.ExtrudeGeometry(tailShape, {
        depth: size * 0.1,
        bevelEnabled: true,
        bevelThickness: size * 0.02,
        bevelSize: size * 0.02,
        bevelSegments: 2
      });
      const tailMat = new THREE.MeshPhysicalMaterial({
        color: baseColor.clone().multiplyScalar(0.8),
        roughness: 0.4,
        metalness: 0.1,
        emissive: emissiveColor,
        emissiveIntensity: emissiveIntensity * 0.7,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      const tail = new THREE.Mesh(tailGeom, tailMat);
      tail.position.set(-size * 1.5, 0, -size * 0.05);
      tail.rotation.y = Math.PI;
      group.add(tail);

      // Dorsal fin
      const dorsalShape = new THREE.Shape();
      dorsalShape.moveTo(0, 0);
      dorsalShape.quadraticCurveTo(size * 0.3, size * 0.5, size * 0.6, 0);
      dorsalShape.lineTo(0, 0);
      
      const dorsalGeom = new THREE.ExtrudeGeometry(dorsalShape, {
        depth: size * 0.05,
        bevelEnabled: false
      });
      const dorsal = new THREE.Mesh(dorsalGeom, tailMat);
      dorsal.position.set(-size * 0.1, size * 0.35, -size * 0.025);
      dorsal.rotation.z = -0.2;
      group.add(dorsal);

      // Side fins
      const finShape = new THREE.Shape();
      finShape.moveTo(0, 0);
      finShape.quadraticCurveTo(size * 0.3, -size * 0.15, size * 0.5, -size * 0.3);
      finShape.quadraticCurveTo(size * 0.2, -size * 0.1, 0, 0);
      
      const finGeom = new THREE.ExtrudeGeometry(finShape, {
        depth: size * 0.02,
        bevelEnabled: false
      });
      
      const leftFin = new THREE.Mesh(finGeom, tailMat);
      leftFin.position.set(size * 0.3, -size * 0.1, size * 0.25);
      leftFin.rotation.x = -0.3;
      group.add(leftFin);
      
      const rightFin = new THREE.Mesh(finGeom, tailMat);
      rightFin.position.set(size * 0.3, -size * 0.1, -size * 0.25);
      rightFin.rotation.x = 0.3;
      rightFin.scale.z = -1;
      group.add(rightFin);

      // Eyes
      const eyeGeom = new THREE.SphereGeometry(size * 0.12, 16, 16);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      
      const eyeWhiteGeom = new THREE.SphereGeometry(size * 0.15, 16, 16);
      
      const leftEyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
      leftEyeWhite.position.set(size * 1.3, size * 0.15, size * 0.2);
      group.add(leftEyeWhite);
      
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(size * 1.4, size * 0.15, size * 0.25);
      group.add(leftEye);
      
      const rightEyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
      rightEyeWhite.position.set(size * 1.3, size * 0.15, -size * 0.2);
      group.add(rightEyeWhite);
      
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(size * 1.4, size * 0.15, -size * 0.25);
      group.add(rightEye);

      return group;
    }

    // Create comet fish (smaller, more streamlined)
    function createCometFish(size = 1.4) {
      const group = new THREE.Group();
      
      // Streamlined body
      const bodyGeom = new THREE.SphereGeometry(size, 24, 18);
      bodyGeom.scale(2, 0.5, 0.4);
      const bodyMat = new THREE.MeshPhysicalMaterial({
        color: 0xd8f7ff,
        emissive: 0x9fdfff,
        emissiveIntensity: 2.2,
        roughness: 0.2,
        transmission: 0.65,
        thickness: 0.8,
        clearcoat: 1
      });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      group.add(body);

      // Flowing tail
      const tailShape = new THREE.Shape();
      tailShape.moveTo(0, 0);
      tailShape.bezierCurveTo(-size, size * 0.8, -size * 1.5, size * 0.3, -size * 2, size * 0.5);
      tailShape.lineTo(-size * 2.2, 0);
      tailShape.lineTo(-size * 2, -size * 0.5);
      tailShape.bezierCurveTo(-size * 1.5, -size * 0.3, -size, -size * 0.8, 0, 0);
      
      const tailGeom = new THREE.ExtrudeGeometry(tailShape, {
        depth: size * 0.08,
        bevelEnabled: true,
        bevelThickness: size * 0.02,
        bevelSize: size * 0.02,
        bevelSegments: 2
      });
      const tailMat = new THREE.MeshPhysicalMaterial({
        color: 0xaef4ff,
        emissive: 0x7fefff,
        emissiveIntensity: 1.8,
        roughness: 0.3,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      const tail = new THREE.Mesh(tailGeom, tailMat);
      tail.position.set(-size * 1.5, 0, -size * 0.04);
      group.add(tail);

      // Eyes
      const eyeGeom = new THREE.SphereGeometry(size * 0.1, 12, 12);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000033 });
      
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(size * 1.5, size * 0.1, size * 0.15);
      group.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(size * 1.5, size * 0.1, -size * 0.15);
      group.add(rightEye);

      return group;
    }

    // Bubble particles (like stars but bubbly)
    const bubbleGeometry = new THREE.BufferGeometry();
    const bubbleVertices = [];
    for (let i = 0; i < 1500; i++) {
      bubbleVertices.push(
        THREE.MathUtils.randFloatSpread(3000),
        THREE.MathUtils.randFloatSpread(3000),
        THREE.MathUtils.randFloatSpread(3000)
      );
    }
    bubbleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bubbleVertices, 3));
    const bubbleMaterial = new THREE.PointsMaterial({ 
      color: 0xaaddff, 
      size: 2.5, 
      sizeAttenuation: true, 
      transparent: true, 
      opacity: 0.5 
    });
    const bubbles = new THREE.Points(bubbleGeometry, bubbleMaterial);
    scene.add(bubbles);

    const ambient = new THREE.AmbientLight(0x4a6a8a, 0.75);
    scene.add(ambient);

    const hemiLight = new THREE.HemisphereLight(0x6c9dff, 0x021020, 0.6);
    scene.add(hemiLight);

    const rimLight = new THREE.DirectionalLight(0x88c4ff, 0.9);
    rimLight.position.set(120, 160, -80);
    scene.add(rimLight);

    // Sun Fish (big golden koi)
    const sunFish = createFishMesh(12, 0xfff1c0, 1.8);
    sunFish.scale.set(1.5, 1.5, 1.5);
    scene.add(sunFish);

    const sunLight = new THREE.PointLight(0xfff0c1, 4.5, 0, 2);
    sunLight.position.copy(sunFish.position);
    scene.add(sunLight);

    const planetConfigs = [
      { name: 'Mercury', radius: 32, size: 2.2, color: 0xc5b199, speed: 1.25, mass: 6 },
      { name: 'Venus', radius: 50, size: 4, color: 0xf5a971, speed: 1.1, mass: 12 },
      { name: 'Earth', radius: 70, size: 4.6, color: 0x5eb7ff, speed: 1.0, mass: 14, tilt: 6 },
      { name: 'Mars', radius: 90, size: 3.2, color: 0xf16b5b, speed: 0.85, mass: 7 },
      { name: 'Jupiter', radius: 130, size: 10, color: 0xefd08a, speed: 0.55, mass: 70 },
      { name: 'Saturn', radius: 170, size: 8.5, color: 0xd9b578, speed: 0.45, mass: 60, rings: { inner: 11, outer: 15 } },
      { name: 'Uranus', radius: 200, size: 6.3, color: 0x74f0d4, speed: 0.3, mass: 40 },
      { name: 'Neptune', radius: 230, size: 6.1, color: 0x60a8ff, speed: 0.28, mass: 45 }
    ];

    function createOrbit(radius) {
      const points = [];
      const segments = 256;
      for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(theta) * radius, 0, Math.sin(theta) * radius));
      }
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x1a3050, transparent: true, opacity: 0.25 });
      const line = new THREE.LineLoop(geometry, material);
      scene.add(line);
    }

    function orbitalVelocity(radius, speedFactor = 1) {
      return Math.sqrt((G * SUN_MASS) / radius) * speedFactor;
    }

    const planetStates = planetConfigs.map(cfg => {
      const mesh = createFishMesh(cfg.size, cfg.color);
      mesh.userData = cfg;

      // Saturn gets bubble ring instead
      if (cfg.rings) {
        const ringGeometry = new THREE.TorusGeometry(cfg.rings.outer, 1.5, 8, 48);
        const ringMat = new THREE.MeshBasicMaterial({ 
          color: 0xf6e1b1, 
          transparent: true, 
          opacity: 0.4,
          wireframe: true 
        });
        const rings = new THREE.Mesh(ringGeometry, ringMat);
        rings.rotation.x = Math.PI / 2;
        mesh.add(rings);
      }

      createOrbit(cfg.radius);
      scene.add(mesh);

      const position = new THREE.Vector3(cfg.radius, 0, 0);
      const velocity = new THREE.Vector3(0, 0, orbitalVelocity(cfg.radius, cfg.speed));
      mesh.position.copy(position);

      const trailPositions = new Float32Array(PLANET_TRAIL_SEGMENTS * 3);
      for (let i = 0; i < PLANET_TRAIL_SEGMENTS; i++) {
        trailPositions[i * 3] = position.x;
        trailPositions[i * 3 + 1] = position.y;
        trailPositions[i * 3 + 2] = position.z;
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const baseColor = new THREE.Color(cfg.color);
      const trailMaterial = new THREE.LineBasicMaterial({
        color: baseColor.clone().lerp(new THREE.Color(0xffffff), 0.2).getHex(),
        transparent: true,
        opacity: 0.28
      });
      const trail = new THREE.Line(trailGeometry, trailMaterial);
      trail.frustumCulled = false;
      scene.add(trail);

      return {
        cfg,
        mesh,
        position,
        velocity,
        mass: cfg.mass,
        wobbleSeed: Math.random() * Math.PI * 2,
        trail,
        trailGeometry,
        trailPositions,
        swimPhase: Math.random() * Math.PI * 2
      };
    });

    // Moon fish (tiny silverfish)
    const moonFish = createFishMesh(0.8, 0xf6f3ef, 0.3);
    moonFish.scale.set(1.2, 1.2, 1.2);
    scene.add(moonFish);

    const comets = [];
    let cometSpawnTimer = 6;
    const impactFlares = [];
    let moonPhase = 0;
    let simTime = 0;

    function computeGravity(sourcePos, targetPos, mass) {
      const dir = new THREE.Vector3().copy(sourcePos).sub(targetPos);
      const distSq = Math.max(dir.lengthSq(), 25);
      return dir.multiplyScalar((G * mass) / Math.pow(distSq, 1.5));
    }

    function updatePlanetTrail(state) {
      const pos = state.trailPositions;
      for (let i = pos.length - 1; i >= 3; i -= 3) {
        pos[i] = pos[i - 3];
        pos[i - 1] = pos[i - 4];
        pos[i - 2] = pos[i - 5];
      }
      pos[0] = state.mesh.position.x;
      pos[1] = state.mesh.position.y;
      pos[2] = state.mesh.position.z;
      state.trailGeometry.attributes.position.needsUpdate = true;
    }

    function updatePlanets(dt) {
      for (const state of planetStates) {
        const accel = computeGravity(sunFish.position, state.position, SUN_MASS);
        state.velocity.addScaledVector(accel, dt);
        state.position.addScaledVector(state.velocity, dt);
        const wobble = state.cfg.tilt ? Math.sin(state.wobbleSeed + simTime * 0.12) * state.cfg.tilt : 0;
        
        // Swimming motion
        state.swimPhase += dt * 0.15;
        const swimWobble = Math.sin(state.swimPhase) * 1.5;
        
        state.mesh.position.set(state.position.x, wobble + swimWobble, state.position.z);
        
        // Make fish face direction of travel
        const angle = Math.atan2(state.velocity.x, state.velocity.z);
        state.mesh.rotation.y = angle + Math.PI / 2;
        
        // Gentle swimming tilt
        state.mesh.rotation.z = Math.sin(state.swimPhase * 2) * 0.1;
        
        updatePlanetTrail(state);
      }
    }

    function updateMoon(dt) {
      const earth = planetStates.find(state => state.cfg.name === 'Earth');
      if (!earth) return;
      moonPhase += dt * 0.35;
      const moonX = earth.position.x + Math.cos(moonPhase) * 12;
      const moonZ = earth.position.z + Math.sin(moonPhase) * 12;
      moonFish.position.set(
        moonX,
        earth.mesh.position.y + Math.sin(moonPhase * 1.5) * 2,
        moonZ
      );
      // Face direction of orbit
      moonFish.rotation.y = moonPhase + Math.PI / 2;
    }

    function updateSunFish(dt) {
      // Gentle wobbling for the sun fish
      sunFish.rotation.y += 0.002 * dt;
      sunFish.position.y = Math.sin(simTime * 0.05) * 2;
      sunFish.rotation.z = Math.sin(simTime * 0.08) * 0.05;
    }

    function spawnComet() {
      const startAngle = Math.random() * Math.PI * 2;
      const radius = THREE.MathUtils.randFloat(260, 360);
      const height = THREE.MathUtils.randFloat(-20, 20);
      const start = new THREE.Vector3(
        Math.cos(startAngle) * radius,
        height,
        Math.sin(startAngle) * radius
      );
      const toSun = new THREE.Vector3().copy(sunFish.position).sub(start).normalize();
      const tangent = new THREE.Vector3(-toSun.z, THREE.MathUtils.randFloat(-0.15, 0.15), toSun.x).normalize();
      const velocity = toSun.multiplyScalar(THREE.MathUtils.randFloat(1.2, 1.9))
        .add(tangent.multiplyScalar(THREE.MathUtils.randFloat(1.2, 2.4)));

      const cometMesh = createCometFish(1.4);
      cometMesh.position.copy(start);
      scene.add(cometMesh);

      const trailPositions = new Float32Array(COMET_TRAIL_SEGMENTS * 3);
      for (let i = 0; i < COMET_TRAIL_SEGMENTS; i++) {
        trailPositions[i * 3] = start.x;
        trailPositions[i * 3 + 1] = start.y;
        trailPositions[i * 3 + 2] = start.z;
      }
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailLine = new THREE.Line(
        trailGeometry,
        new THREE.LineBasicMaterial({ color: 0x9ae5ff, transparent: true, opacity: 0.7 })
      );
      scene.add(trailLine);

      comets.push({
        mesh: cometMesh,
        position: start,
        velocity,
        trailGeometry,
        trailPositions,
        trailLine,
        alive: true,
        swimPhase: Math.random() * Math.PI * 2
      });
    }

    function updateCometTrail(comet) {
      const pos = comet.trailPositions;
      for (let i = pos.length - 1; i >= 3; i -= 3) {
        pos[i] = pos[i - 3];
        pos[i - 1] = pos[i - 4];
        pos[i - 2] = pos[i - 5];
      }
      pos[0] = comet.position.x;
      pos[1] = comet.position.y;
      pos[2] = comet.position.z;
      comet.trailGeometry.attributes.position.needsUpdate = true;
    }

    function createImpactFlash(position, color) {
      // Bubble burst effect
      const burstGroup = new THREE.Group();
      for (let i = 0; i < 8; i++) {
        const bubble = new THREE.Mesh(
          new THREE.SphereGeometry(1.5, 12, 12),
          new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 })
        );
        const angle = (i / 8) * Math.PI * 2;
        bubble.position.set(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
        burstGroup.add(bubble);
      }
      burstGroup.position.copy(position);
      scene.add(burstGroup);
      impactFlares.push({ mesh: burstGroup, life: 1.2, isBurst: true });
    }

    function updateFlares(dt) {
      for (let i = impactFlares.length - 1; i >= 0; i--) {
        const flare = impactFlares[i];
        flare.life -= dt * 0.8;
        flare.mesh.scale.addScalar(dt * 0.8);
        if (flare.isBurst) {
          flare.mesh.children.forEach(child => {
            child.material.opacity = Math.max(flare.life / 1.2, 0);
          });
        } else {
          flare.mesh.material.opacity = Math.max(flare.life / 1.2, 0);
        }
        if (flare.life <= 0) {
          scene.remove(flare.mesh);
          if (flare.isBurst) {
            flare.mesh.children.forEach(child => {
              child.geometry.dispose();
              child.material.dispose();
            });
          } else {
            flare.mesh.geometry.dispose();
            flare.mesh.material.dispose();
          }
          impactFlares.splice(i, 1);
        }
      }
    }

    function disposeComet(comet) {
      scene.remove(comet.mesh);
      scene.remove(comet.trailLine);
      comet.mesh.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      comet.trailGeometry.dispose();
      comet.trailLine.material.dispose();
    }

    function updateComets(dt) {
      cometSpawnTimer -= dt;
      if (cometSpawnTimer <= 0 && comets.length < MAX_COMETS) {
        spawnComet();
        cometSpawnTimer = THREE.MathUtils.randFloat(COMET_MIN_DELAY, COMET_MAX_DELAY);
      }

      for (let i = comets.length - 1; i >= 0; i--) {
        const comet = comets[i];
        let acceleration = computeGravity(sunFish.position, comet.position, SUN_MASS);
        for (const state of planetStates) {
          const dir = new THREE.Vector3().copy(state.position).sub(comet.position);
          const distSq = Math.max(dir.lengthSq(), 9);
          const grav = dir.multiplyScalar((G * state.mass * 4000) / Math.pow(distSq, 1.5));
          acceleration.add(grav);
          if (Math.sqrt(distSq) < state.cfg.size + 1.8) {
            comet.alive = false;
            createImpactFlash(state.position, state.cfg.color);
            break;
          }
        }

        comet.velocity.addScaledVector(acceleration, dt);
        comet.position.addScaledVector(comet.velocity, dt);
        comet.mesh.position.copy(comet.position);
        
        // Swimming motion for comet fish
        comet.swimPhase += dt * 0.3;
        comet.mesh.position.y += Math.sin(comet.swimPhase) * 0.5;
        
        // Face direction of travel
        const angle = Math.atan2(comet.velocity.x, comet.velocity.z);
        comet.mesh.rotation.y = angle + Math.PI / 2;
        comet.mesh.rotation.z = Math.sin(comet.swimPhase * 2) * 0.15;
        
        updateCometTrail(comet);

        if (!comet.alive || comet.position.length() > COMET_MAX_DISTANCE) {
          disposeComet(comet);
          comets.splice(i, 1);
        }
      }
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(clock.getDelta(), 0.05);
      const dt = delta * TIME_ACCEL;
      simTime += dt;

      updatePlanets(dt);
      updateMoon(dt);
      updateComets(dt);
      updateFlares(dt);
      updateSunFish(dt);

      // Gentle bubble movement
      bubbles.rotation.y += 0.0001 * dt;
      
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      const { innerWidth, innerHeight } = window;
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
